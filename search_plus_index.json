{"./":{"url":"./","title":"Introduction","keywords":"","body":" Introduction Silm 是一个php轻框架，旨在提供快速开发出强大的web应用和接口 get('/hello/{name}', function (Request $request, Response $response, array $args) { $name = $args['name']; $response->getBody()->write(\"Hello, $name\"); return $response; }); $app->run(); 安装 初次创建项目 composer create-project slim/slim-skeleton:dev-master [my-app-name] 自建项目目录之后直接compose 引入 composer require slim/slim 学习或者初始项目建议按第一种方式安装，里面已经包含了比较规范的目录结构，参照DDD模型设计，还包含了测试用例，路由示例，中间件示例，基础设置持久化示例等等 特色 HTTP Router Slim provides a fast and powerful router that maps route callbacks to specific HTTP request methods and URIs. It supports parameters and pattern matching. HTTP 路由 Slim 提供了一个强大快速的路由器，能快速映射HTTP请求和URIs，支持参数设置和模式匹配 Middleware Build your application with concentric middleware to tweak the HTTP request and response objects around your Slim app. 中间件 围绕http请求和响应的中间件层来构建应用 PSR-7 Support Slim supports any PSR-7 HTTP message implementation so you may inspect and manipulate HTTP message method, status, URI, headers, cookies, and body. PSR-7 规范支持 Slim 广泛实现了PSR-7设计的HTTPP相关的接口，使其可以方便使用实现接口的第三方库 Dependency Injection Slim supports dependency injection so you have complete control of your external tools. Use any Container-Interop container. 依赖注入 Slim 提供了容器，方便依赖注入 核心架构图示 总结 Slim 相对其他的轻框架比较更加高效，扩展能力更强，容易集成第三方类库的使用，相对YII这种大型框架比较灵活，框架束缚比较少，相应的提供的能力没那么强。Slim更多处理简易项目和API接口项目比较方便，中间件的灵活使用也使得应用结构简单，更加模块化。 "},"1-get-started/1-home.html":{"url":"1-get-started/1-home.html","title":"Home","keywords":"","body":"Slim 4 Documentation Welcome Slim is a PHP micro framework that helps you quickly write simple yet powerful web applications and APIs. At its core, Slim is a dispatcher that receives an HTTP request, invokes an appropriate callback routine, and returns an HTTP response. That’s it. Slim 是一个轻型的php框架，旨在帮助你快速构建强大的web application 和 APIs。Slim的核心是一个调度器，接受HTTP请求，唤醒合适的回调逻辑处理之后返回一个HTTP 响应。这就是全部。 Slim 核心代码提供的功能有限，比较适合轻型项目和接口类型的项目。 What’s the point? Symfony or Laravel 是非常好的框架，但是对于轻型项目没必要。正常的一个http请求从客户端发起到服务器接受，经过路由处理解析成对应的controller 和 action 以及参数，执行完成业务逻辑之后返回一个HTTP响应给到客户端，这就是整个基本的核心逻辑。其中还有很多逻辑，比如登录态校验，参数校验，拦截器，权限校验等等大型框架集成的东西，在一个微型的项目中可能用不到。所以Slim 秉承实现最小的原则，仅仅实现了核心的路由解析调度，中间件调度器的逻辑，其他逻辑开发者可以自行扩展。Slim生态中有很多开源的中间件，基本都遵循prs-7,prs-15等接口规范，开箱即用。开发者可以自己在核心之外，中间件的链路上集成对请求和响应的处理逻辑。框架之外，Slim并不限制项目的架构模式，可以单纯的函数，也可以是简易的MVC，也可以是比较复杂的DDD架构（Slim create project 就是推荐这种架构模式）。开发者可以灵活地调整合适的架构。 ​ 并没有什么完美的架构，恰当即完美 Slim的开发者多次强调了这段话，可以细品 ***At its core, Slim is a dispatcher that receives an HTTP request, invokes an appropriate callback routine, and returns an HTTP response. That’s it*** 原文 Slim is an ideal tool to create APIs that consume, repurpose, or publish data. Slim is also a great tool for rapid prototyping. Heck, you can even build full-featured web applications with user interfaces. More importantly, Slim is super fast and has very little code. In fact, you can read and understand its source code in only an afternoon! You don’t always need a kitchen-sink solution like Symfony or Laravel. These are great tools, for sure. But they are often overkill. Instead, Slim provides only a minimal set of tools that do what you need and nothing else. How does it work? First, you need a web server like Nginx or Apache. You should configure your web server so that it sends all appropriate requests to one “front-controller” PHP file. You instantiate and run your Slim app in this PHP file. A Slim app contains routes that respond to specific HTTP requests. Each route invokes a callback and returns an HTTP response. To get started, you first instantiate and configure the Slim application. Next, you define your application routes. Finally, you run the Slim application. It’s that easy. Here’s an example application: 本地开发或者调试可以使用browser或者IDE的HTTP-Client + 内置的web服务器 php -S 推荐部署nginx服务器，可以解决后端源码，前端静态资源目录，路径设置等可能引起的问题。 类似所有的框架一样，必然有一个入口文件，比如index.php 整个请求由此开始... Slim应用主要就是处理请求并生成一个响应。每一个路由唤醒的调用逻辑都接受一个Request的类，处理完成之后返回一个Respose的类。 通常index.php 实现了以下逻辑: 1 定义常量或者引入常量文件 2 引入自动加载文件，可以多个 ​ 按加载的顺序查找，相同的文件一般用namespace区分 3 如果需要，实例化容器，将初始化的类或者参数绑定到容器 4 实例化Slim App 5 引入或者设置 当前app的路由配置 6 引入或者设置中间件配置文件 除了5,6需要绑定app必须在实例化之后，很多其他的逻辑，比如日志，渲染器等等的使用视情况而定 run(); 官方的例子和说明 addRoutingMiddleware(); /** * Add Error Handling Middleware * * @param bool $displayErrorDetails -> Should be set to false in production * @param bool $logErrors -> Parameter is passed to the default ErrorHandler * @param bool $logErrorDetails -> Display error details in error log * which can be replaced by a callable of your choice. * Note: This middleware should be added last. It will not handle any exceptions/errors * for middleware added after it. */ $errorMiddleware = $app->addErrorMiddleware(true, true, true); // Define app routes $app->get('/hello/{name}', function (Request $request, Response $response, $args) { $name = $args['name']; $response->getBody()->write(\"Hello, $name\"); return $response; }); // Run app $app->run(); Request and response 官方注解，比较能反映Slim的设计哲学，明白这个之后，理解源码就比较轻松了 When you build a Slim app, you are often working directly with Request and Response objects. These objects represent the actual HTTP request received by the web server and the eventual HTTP response returned to the client. Every Slim app route is given the current Request and Response objects as arguments to its callback routine. These objects implement the popular PSR-7 interfaces. The Slim app route can inspect or manipulate these objects as necessary. Ultimately, each Slim app route MUST return a PSR-7 Response object. "},"1-get-started/2-installtion.html":{"url":"1-get-started/2-installtion.html","title":"Installtion","keywords":"","body":"Installation System Requirements Web server with URL rewriting PHP 7.2 or newer Step 1: Install Composer Step 2: Install Slim 已有MCV代码了 composer require slim/slim 初始化项目建议以下 compser create-project slim/slim-skeleton:dev-master [my-app-name] Step 3: Install a PSR-7 Implementation and ServerRequest Creator 这一步必须要，Slim源码中只定义了默认的类，但是没有安装第三方的类库 Slim PSR-7 建议安装Slim 官方的，其他的不知道后续是不是继续维护 composer require slim/psr7 Step 4: Hello World get('/', function (Request $request, Response $response, $args) { $response->getBody()->write(\"Hello world!\"); return $response; }); $app->run(); "},"1-get-started/3-web-servers.html":{"url":"1-get-started/3-web-servers.html","title":"Web Servers","keywords":"","body":"Web Servers It is typical to use the front-controller pattern to funnel appropriate HTTP requests received by your web server to a single PHP file. The instructions below explain how to tell your web server to send HTTP requests to your PHP front-controller file. PHP built-in server cd public/ php -S localhost:8888 Nginx configuration server { charset utf-8; client_max_body_size 128M; listen 80; ## listen for ipv4 server_name server_name.com; root /your/path; #index web/index.html; access_log /your/path/access.log; error_log /your/path/error.log; location / { try_files /web/$uri /web/index.html 404; } location ~ \\.(txt|xml|js|vue|css|ttf)$ { try_files /web/$uri /web/index.html 404; expires 7d; } location ~ \\.(jpg|jpeg|gif|png|ico)$ { try_files /web/$uri /web/index.html 404; expires 30m; } location /protected { deny all; } location ~ \\.php$ { add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type'; add_header 'Access-Control-Allow-Origin' \"$http_origin\"; add_header 'Access-Control-Allow-Credentials' \"true\"; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_param REQUEST_URI $php_url?$args; fastcgi_param REAL_REQUEST_URI $request_uri; fastcgi_pass 127.0.0.1:9000; try_files $uri =404; } location ~ /\\.(ht|svn|git) { deny all; } location ~* ^/api(/.*)$ { set $php_url $1; try_files $uri $uri/ /index-test.php?$args; # 根据环境路由到不同的入口文件 } } "},"1-get-started/4-deployment.html":{"url":"1-get-started/4-deployment.html","title":"Deployment","keywords":"","body":"Deployment Disable error display in production addErrorMiddleware(false, true, true); // ... $app->run(); "},"2-concepts/1-application-life-cycle.html":{"url":"2-concepts/1-application-life-cycle.html","title":"Application Life Cycle","keywords":"","body":"Lifecycle Application Life Cycle Instantiation 实例化Slim\\App ,在实例化过程中，Slim为每个应用独立注册默认的服务 Route Definitions 定义路由，get() post() patch() head() option() put() delete() 可以选择匿名函数或者指定类名 Application Runner 实例化APP 调用run() A. Enter Middleware Stack Middlewares 在设置的时候，根据顺序已经构建了执行链路，app->run() 调用每一层的中间件执行逻辑，并以此唤醒下一层的中间件，直至到达最里面的核心，核心执行完业务逻辑，中间件以此返回一个response B. Run Application 最里面一层裹着的是路由中间件，HTTP request 到达之后，调用路由解析器，查找对应的回调函数是否存在，不存在则抛出route is not found. Not Found 或者 Not Allowed handler 被唤醒 C. Exit Middleware Stack 所有的中间件的process执行完毕，response到达最外面一层 D. Send HTTP Response 调用php原生函数header,body等，输出buffer 参考架构图 "},"2-concepts/2-psr-7.html":{"url":"2-concepts/2-psr-7.html","title":"Psr 7","keywords":"","body":"PSR-7 and Value Objects Slim supports PSR-7 interfaces for its Request and Response objects. This makes Slim flexible because it can use any PSR-7 implementation. For example, you could return an instance of GuzzleHttp\\Psr7\\CachingStream or any instance returned by the GuzzleHttp\\Psr7\\stream_for() function. Slim provides its own PSR-7 implementation so that it works out of the box. However, you are free to replace Slim’s default PSR-7 objects with a third-party implementation. Just override the application container’s request and response services so they return an instance of Psr\\Http\\Message\\ServerRequestInterface and Psr\\Http\\Message\\ResponseInterface, respectively. Slim request 和 response 实现了PSR-7，带给了Slim非常灵活的组件选择，只要实现了PSR-7的HTTP request和response都可以替换。 中间件 实现 MiddlewareInface 处理请求实现 ResquestHandleInterface Value objects 值对象不可修改 Request and Response objects are immutable value objects. They can be “changed” only by requesting a cloned version that has updated property values. Value objects have a nominal overhead because they must be cloned when their properties are updated. This overhead does not affect performance in any meaningful way. You can request a copy of a value object by invoking any of its PSR-7 interface methods (these methods typically have a with prefix). For example, a PSR-7 Response object has a withHeader($name, $value) method that returns a cloned value object with the new HTTP header. get('/foo', function (Request $request, Response $response, array $args) { $payload = json_encode(['hello' => 'world'], JSON_PRETTY_PRINT); $response->getBody()->write($payload); return $response->withHeader('Content-Type', 'application/json'); }); $app->run(); The PSR-7 interface provides these methods to transform Request and Response objects: withProtocolVersion($version) withHeader($name, $value) withAddedHeader($name, $value) withoutHeader($name) withBody(StreamInterface $body) The PSR-7 interface provides these methods to transform Request objects: withMethod($method) withUri(UriInterface $uri, $preserveHost = false) withCookieParams(array $cookies) withQueryParams(array $query) withUploadedFiles(array $uploadedFiles) withParsedBody($data) withAttribute($name, $value) withoutAttribute($name) The PSR-7 interface provides these methods to transform Response objects: withStatus($code, $reasonPhrase = '') Refer to the PSR-7 documentation for more information about these methods. 总结 实现接口的好处，可以模拟request和response，单元测试 面对接口编程，代码协议 值对象属性 不可修改 需要修改重新clone对象返回 "},"2-concepts/3-middleware.html":{"url":"2-concepts/3-middleware.html","title":"Middleware","keywords":"","body":"Middleware You can run code before and after your Slim application to manipulate the Request and Response objects as you see fit. This is called middleware. Why would you want to do this? Perhaps you want to protect your app from cross-site request forgery. Maybe you want to authenticate requests before your app runs. Middleware is perfect for these scenarios. 在处理request 和 response过程中，可以在之前或者之后运行逻辑。中间件聚合某一类逻辑 What is middleware? A middleware implements the PSR-15 Middleware Interface: Psr\\Http\\Message\\ServerRequestInterface - The PSR-7 request object Psr\\Http\\Server\\RequestHandlerInterface - The PSR-15 request handler object It can do whatever is appropriate with these objects. The only hard requirement is that a middleware MUST return an instance of Psr\\Http\\Message\\ResponseInterface. Each middleware SHOULD invoke the next middleware and pass it Request and Response objects as arguments. 替换原则就必须要求面向接口，面向抽象编程 热插拔原则就必须要求能接受前一个节点的调用，能唤醒下一个节点 How does middleware work? do somthing $response = nextMiddleware->process($request); do somthing return $response; Different frameworks use middleware differently. Slim adds middleware as concentric layers surrounding your core application. Each new middleware layer surrounds any existing middleware layers. The concentric structure expands outwardly as additional middleware layers are added. The last middleware layer added is the first to be executed.（LIFO） When you run the Slim application, the Request object traverses the middleware structure from the outside in. They first enter the outer-most middleware, then the next outer-most middleware, (and so on), until they ultimately arrive at the Slim application itself. After the Slim application dispatches the appropriate route, the resultant Response object exits the Slim application and traverses the middleware structure from the inside out. Ultimately, a final Response object exits the outer-most middleware, is serialized into a raw HTTP response, and is returned to the HTTP client. Here’s a diagram that illustrates the middleware process flow: How do I write middleware? 必须实现中间件接口 Middleware is a callable that accepts two arguments: a Request object and a RequestHandler object. Each middleware MUST return an instance of Psr\\Http\\Message\\ResponseInterface. Closure middleware example. This example middleware is a Closure. 闭包模式 handle($request); $existingContent = (string) $response->getBody(); $response = new Response(); $response->getBody()->write('BEFORE' . $existingContent); return $response; }; $afterMiddleware = function ($request, $handler) { $response = $handler->handle($request); $response->getBody()->write('AFTER'); return $response; }; $app->add($beforeMiddleware); $app->add($afterMiddleware); // ... $app->run(); Invokable class middleware example 参考最新的写法，每个中间件实现process() This example middleware is an invokable class that implements the magic __invoke() method. handle($request); $existingContent = (string) $response->getBody(); $response = new Response(); $response->getBody()->write('BEFORE' . $existingContent); return $response; } } handle($request); $response->getBody()->write('AFTER'); return $response; } } To use these classes as a middleware, you can use add(new ExampleMiddleware()); function chain after the $app route mapping methods get(), post(), put(), patch(), delete(), options(), any() or group(), which in the code below, any one of these, could represent $subject. add(new ExampleMiddleware()); // Add Middleware On Route $app->get('/', function () { ... })->add(new ExampleMiddleware()); // Add Middleware On Group $app->group('/', function () { ... })->add(new ExampleMiddleware()); // ... $app->run(); How do I add middleware? You may add middleware to a Slim application, to an individual Slim application route or to a route group. All scenarios accept the same middleware and implement the same middleware interface. Application middleware Application middleware is invoked for every incoming HTTP request. Add application middleware with the Slim application instance’s add() method. This example adds the Closure middleware example above: add(function (Request $request, RequestHandler $handler) { $response = $handler->handle($request); $existingContent = (string) $response->getBody(); $response = new Response(); $response->getBody()->write('BEFORE ' . $existingContent); return $response; }); $app->add(function (Request $request, RequestHandler $handler) { $response = $handler->handle($request); $response->getBody()->write(' AFTER'); return $response; }); $app->get('/', function (Request $request, Response $response, $args) { $response->getBody()->write('Hello World'); return $response; }); $app->run(); This would output this HTTP response body: BEFORE Hello World AFTER Route middleware Route middleware is invoked only if its route matches the current HTTP request method and URI. Route middleware is specified immediately after you invoke any of the Slim application’s routing methods (e.g., get() or post()). Each routing method returns an instance of \\Slim\\Route, and this class provides the same middleware interface as the Slim application instance. Add middleware to a Route with the Route instance’s add() method. This example adds the Closure middleware example above: handle($request); $response->getBody()->write('World'); return $response; }; $app->get('/', function (Request $request, Response $response, $args) { $response->getBody()->write('Hello '); return $response; })->add($mw); $app->run(); This would output this HTTP response body: Hello World Group middleware In addition to the overall application, and standard routes being able to accept middleware, the group() multi-route definition functionality, also allows individual routes internally. Route group middleware is invoked only if its route matches one of the defined HTTP request methods and URIs from the group. To add middleware within the callback, and entire-group middleware to be set by chaining add() after the group() method. Sample Application, making use of callback middleware on a group of url-handlers get('/', function (Request $request, Response $response) { $response->getBody()->write('Hello World'); return $response; }); $app->group('/utils', function (RouteCollectorProxy $group) { $group->get('/date', function (Request $request, Response $response) { $response->getBody()->write(date('Y-m-d H:i:s')); return $response; }); $group->get('/time', function (Request $request, Response $response) { $response->getBody()->write((string)time()); return $response; }); })->add(function (Request $request, RequestHandler $handler) use ($app) { $response = $handler->handle($request); $dateOrTime = (string) $response->getBody(); $response = $app->getResponseFactory()->createResponse(); $response->getBody()->write('It is now ' . $dateOrTime . '. Enjoy!'); return $response; }); $app->run(); When calling the /utils/date method, this would output a string similar to the below It is now 2015-07-06 03:11:01. Enjoy! Visiting /utils/time would output a string similar to the below It is now 1436148762. Enjoy! But visiting / (domain-root), would be expected to generate the following output as no middleware has been assigned Hello World Passing variables from middleware The easiest way to pass attributes from middleware is to use the request’s attributes. Setting the variable in the middleware: $request = $request->withAttribute('foo', 'bar'); Getting the variable in the route callback: $foo = $request->getAttribute('foo'); 中间件变量保存在request 和 response 属性中 "},"2-concepts/4-dependency-container.html":{"url":"2-concepts/4-dependency-container.html","title":"Dependency Container","keywords":"","body":"Dependency Container Slim uses an optional dependency container to prepare, manage, and inject application dependencies. Slim supports containers that implement PSR-11 like PHP-DI. Example usage with PHP-DI You don’t have to provide a dependency container. If you do, however, you must provide an instance of the container to AppFactory before creating an App. 挂载服务到容器 配置也可以单独挂载到配置项 $container->set('myService', function () { $settings = [...]; return new MyService($settings); }); You can fetch services from your container explicitly as well as from inside a Slim application route like this: 闭包被绑定到了容器上 /** * Example GET route * * @param ServerRequestInterface $request PSR-7 request * @param ResponseInterface $response PSR-7 response * @param array $args Route parameters * * @return ResponseInterface */ $app->get('/foo', function (Request $request, Response $response, $args) { $myService = $this->get('myService'); // ...do something with $myService... return $response; }); To test if a service exists in the container before using it, use the has() method, like this: /** * Example GET route * * @param ServerRequestInterface $request PSR-7 request * @param ResponseInterface $response PSR-7 response * @param array $args Route parameters * * @return ResponseInterface */ $app->get('/foo', function (Request $request, Response $response, $args) { if ($this->has('myService')) { $myService = $this->get('myService'); } return $response; }); Configuring the application via a container In case you want to create the App with dependencies already defined in your container, you can use the AppFactory::createFromContainer() method. Example set(ResponseFactoryInterface::class, function (ContainerInterface $container) { return new MyResponseFactory(...); }); // Configure the application via container $app = AppFactory::createFromContainer($container); // ... $app->run(); Supported App dependencies are: Psr\\Http\\Message\\ResponseFactoryInterface Slim\\Interfaces\\CallableResolverInterface Slim\\Interfaces\\RouteCollectorInterface Slim\\Interfaces\\RouteResolverInterface Slim\\Interfaces\\MiddlewareDispatcherInterface Slim 4的容器依赖注入在构建Controller的时候需要当着__constract的参数传入，没找到其他优雅的方式 /** * @param LoggerInterface $logger * @param UserRepository $userRepository */ public function __construct(LoggerInterface $logger, UserRepository $userRepository,Container $container) { parent::__construct($logger); $this->userRepository = $userRepository; $this->container = $container; } 应用层 Slim的例子是一些Action，绑定到了容器的定义类型属性下面 class ReflectionBasedAutowiring implements DefinitionSource, Autowiring { public function autowire(string $name, ObjectDefinition $definition = null) { $className = $definition ? $definition->getClassName() : $name; if (!class_exists($className) && !interface_exists($className)) { return $definition; } $definition = $definition ?: new ObjectDefinition($name); // Constructor $class = new \\ReflectionClass($className); $constructor = $class->getConstructor(); if ($constructor && $constructor->isPublic()) { $constructorInjection = MethodInjection::constructor($this->getParametersDefinition($constructor)); $definition->completeConstructorInjection($constructorInjection); } //这里解析了调用的类的构造函数 return $definition; } public function getDefinition(string $name) { return $this->autowire($name); } ... } Tips: Slim 响应response之前 清空了缓冲输出，测试环境调试可以配置此处 withHeader('Access-Control-Allow-Credentials', 'true') ->withHeader('Access-Control-Allow-Origin', $origin) ->withHeader('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Accept, Origin, Authorization') ->withHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE, OPTIONS') ->withHeader('Cache-Control', 'no-store, no-cache, must-revalidate, max-age=0') ->withAddedHeader('Cache-Control', 'post-check=0, pre-check=0') ->withHeader('Pragma', 'no-cache'); //测试环境可以根据配置决定是否注释掉已获得打印的调试数据 // if (ob_get_contents()) { // ob_clean(); //} parent::emit($response); } } Slim DI\\Definition\\Definition 这个库处理了避免类多次实例化的逻辑... "},"3-application/1-overview.html":{"url":"3-application/1-overview.html","title":"Overview","keywords":"","body":"Application The Application Slim\\App is the entry point to your Slim application and is used to register the routes that link to your callbacks or controllers. addErrorMiddleware(true, false, false); // Add route callbacks $app->get('/', function (Request $request, Response $response, array $args) { $response->getBody()->write('Hello World'); return $response; }); // Run application $app->run(); "},"3-application/2-notices-warings-handling.html":{"url":"3-application/2-notices-warings-handling.html","title":"Notices Warings Handling","keywords":"","body":"Advanced Notices and Warnings Handling Warnings and Notices are not caught by default. If you wish your application to display an error page when they happen, you will need to implement code similar to the following index.php. getCallableResolver(); $responseFactory = $app->getResponseFactory(); $serverRequestCreator = ServerRequestCreatorFactory::create(); $request = $serverRequestCreator->createFromGlobals(); $errorHandler = new HttpErrorHandler($callableResolver, $responseFactory); $shutdownHandler = new ShutdownHandler($request, $errorHandler, $displayErrorDetails); register_shutdown_function($shutdownHandler); // Add Routing Middleware $app->addRoutingMiddleware(); // Add Error Handling Middleware $errorMiddleware = $app->addErrorMiddleware($displayErrorDetails, false, false); $errorMiddleware->setDefaultErrorHandler($errorHandler); $app->run(); Advanced Custom Error Handler exception; $statusCode = 500; $type = self::SERVER_ERROR; $description = 'An internal error has occurred while processing your request.'; if ($exception instanceof HttpException) { $statusCode = $exception->getCode(); $description = $exception->getMessage(); if ($exception instanceof HttpNotFoundException) { $type = self::RESOURCE_NOT_FOUND; } elseif ($exception instanceof HttpMethodNotAllowedException) { $type = self::NOT_ALLOWED; } elseif ($exception instanceof HttpUnauthorizedException) { $type = self::UNAUTHENTICATED; } elseif ($exception instanceof HttpForbiddenException) { $type = self::UNAUTHENTICATED; } elseif ($exception instanceof HttpBadRequestException) { $type = self::BAD_REQUEST; } elseif ($exception instanceof HttpNotImplementedException) { $type = self::NOT_IMPLEMENTED; } } if ( !($exception instanceof HttpException) && ($exception instanceof Exception || $exception instanceof Throwable) && $this->displayErrorDetails ) { $description = $exception->getMessage(); } $error = [ 'statusCode' => $statusCode, 'error' => [ 'type' => $type, 'description' => $description, ], ]; $payload = json_encode($error, JSON_PRETTY_PRINT); $response = $this->responseFactory->createResponse($statusCode); $response->getBody()->write($payload); return $response; } } Advanced Shutdown Handler request = $request; $this->errorHandler = $errorHandler; $this->displayErrorDetails = $displayErrorDetails; } public function __invoke() { $error = error_get_last(); if ($error) { $errorFile = $error['file']; $errorLine = $error['line']; $errorMessage = $error['message']; $errorType = $error['type']; $message = 'An error while processing your request. Please try again later.'; if ($this->displayErrorDetails) { switch ($errorType) { case E_USER_ERROR: $message = \"FATAL ERROR: {$errorMessage}. \"; $message .= \" on line {$errorLine} in file {$errorFile}.\"; break; case E_USER_WARNING: $message = \"WARNING: {$errorMessage}\"; break; case E_USER_NOTICE: $message = \"NOTICE: {$errorMessage}\"; break; default: $message = \"ERROR: {$errorMessage}\"; $message .= \" on line {$errorLine} in file {$errorFile}.\"; break; } } $exception = new HttpInternalServerErrorException($this->request, $message); $response = $this->errorHandler->__invoke($this->request, $exception, $this->displayErrorDetails, false, false); if (ob_get_length()) { ob_clean(); } $responseEmitter = new ResponseEmitter(); $responseEmitter->emit($response); } } } "},"4-request/1-overview.html":{"url":"4-request/1-overview.html","title":"Overview","keywords":"","body":"Request Your Slim app’s routes and middleware are given a PSR-7 request object that represents the current HTTP request received by your web server. The request object implements the PSR-7 ServerRequestInterface with which you can inspect and manipulate the HTTP request method, headers, and body. How to get the Request object The PSR-7 request object is injected into your Slim application routes as the first argument to the route callback like this: get('/hello', function (Request $request, Response $response) { $response->getBody()->write('Hello World'); return $response; }); $app->run(); The PSR-7 request object is injected into your Slim application middleware as the first argument of the middleware callable like this: add(function (ServerRequestInterface $request, RequestHandler $handler) { return $handler->handle($request); }); // ...define app routes... $app->run(); "},"4-request/2-method.html":{"url":"4-request/2-method.html","title":"Method","keywords":"","body":"Method The Request Method Every HTTP request has a method that is typically one of: GET POST PUT DELETE HEAD PATCH OPTIONS You can inspect the HTTP request’s method with the Request object method appropriately named getMethod(). $method = $request->getMethod(); It is possible to fake or override the HTTP request method. This is useful if, for example, you need to mimic a PUT request using a traditional web browser that only supports GET or POST requests. Heads Up! To enable request method overriding the Method Overriding Middleware must be injected into your application. There are two ways to override the HTTP request method. You can include a METHOD parameter in a POST request’s body. The HTTP request must use the application/x-www-form-urlencoded content type. POST /path HTTP/1.1 Host: example.com Content-type: application/x-www-form-urlencoded Content-length: 22 data=value&_METHOD=PUT You can also override the HTTP request method with a custom X-Http-Method-Override HTTP request header. This works with any HTTP request content type. POST /path HTTP/1.1 Host: example.com Content-type: application/json Content-length: 16 X-Http-Method-Override: PUT {\"data\":\"value\"} The Request URI Every HTTP request has a URI that identifies the requested application resource. The HTTP request URI has several parts: Scheme (e.g. http or https) Host (e.g. example.com) Port (e.g. 80 or 443) Path (e.g. /users/1) Query string (e.g. sort=created&dir=asc) You can fetch the PSR-7 Request object’s URI object with its getUri() method: $uri = $request->getUri(); The PSR-7 Request object’s URI is itself an object that provides the following methods to inspect the HTTP request’s URL parts: getScheme() getAuthority() getUserInfo() getHost() getPort() getPath() getBasePath() getQuery() (returns the full query string, e.g. a=1&b=2) getFragment() getBaseUrl() You can get the query parameters as an associative array on the Request object using getQueryParams(). Base Path If your Slim application's front-controller lives in a physical subdirectory beneath your document root directory, you can fetch the HTTP request's physical base path (relative to the document root) with the Uri object's getBasePath() method. This will be an empty string if the Slim application is installed in the document root's top-most directory. "},"4-request/3-headers.html":{"url":"4-request/3-headers.html","title":"Headers","keywords":"","body":"Headers The Request Headers Every HTTP request has headers. These are metadata that describe the HTTP request but are not visible in the request’s body. Slim’s PSR-7 Request object provides several methods to inspect its headers. Get All Headers You can fetch all HTTP request headers as an associative array with the PSR-7 Request object’s getHeaders() method. The resultant associative array’s keys are the header names and its values are themselves a numeric array of string values for their respective header name. $headers = $request->getHeaders(); foreach ($headers as $name => $values) { echo $name . \": \" . implode(\", \", $values); } Get One Header You can get a single header’s value(s) with the PSR-7 Request object’s getHeader($name) method. This returns an array of values for the given header name. Remember, a single HTTP header may have more than one value! $headerValueArray = $request->getHeader('Accept'); You may also fetch a comma-separated string with all values for a given header with the PSR-7 Request object’s getHeaderLine($name) method. Unlike the getHeader($name) method, this method returns a comma-separated string. $headerValueString = $request->getHeaderLine('Accept'); Detect Header You can test for the presence of a header with the PSR-7 Request object’s hasHeader($name) method. if ($request->hasHeader('Accept')) { // Do something } "},"4-request/4-body.html":{"url":"4-request/4-body.html","title":"Body","keywords":"","body":"Body The Request Body Every HTTP request has a body. If you are building a Slim application that consumes JSON or XML data, you can use the PSR-7 Request object’s getParsedBody() method to parse the HTTP request body into a native PHP format. Note that body parsing differs from one PSR-7 implementation to another. You may need to implement middleware in order to parse the incoming input depending on the PSR-7 implementation you have installed. Here is an example for parsing incoming JSON input: getHeaderLine('Content-Type'); if (strstr($contentType, 'application/json')) { $contents = json_decode(file_get_contents('php://input'), true); if (json_last_error() === JSON_ERROR_NONE) { $request = $request->withParsedBody($contents); } } return $handler->handle($request); } } $parsedBody = $request->getParsedBody(); Technically speaking, the PSR-7 Request object represents the HTTP request body as an instance of Psr\\Http\\Message\\StreamInterface. You can get the HTTP request body StreamInterface instance with the PSR-7 Request object’s getBody() method. The getBody() method is preferable if the incoming HTTP request size is unknown or too large for available memory. $body = $request->getBody(); The resultant Psr\\Http\\Message\\StreamInterface instance provides the following methods to read and iterate its underlying PHP resource. getSize() tell() eof() isSeekable() seek() rewind() isWritable() write($string) isReadable() read($length) getContents() getMetadata($key = null) "},"4-request/5-uploaded-files.html":{"url":"4-request/5-uploaded-files.html","title":"Uploaded Files","keywords":"","body":"Uploaded Files The file uploads in $_FILES are available from the Request object’s getUploadedFiles() method. This returns an array keyed by the name of the input element. $files = $request->getUploadedFiles(); Each object in the $files array is an instance of Psr\\Http\\Message\\UploadedFileInterface and supports the following methods: getStream() moveTo($targetPath) getSize() getError() getClientFilename() getClientMediaType() See the cookbook on how to upload files using a POST form. "},"4-request/6-helpers.html":{"url":"4-request/6-helpers.html","title":"Helpers","keywords":"","body":"Request Helpers Slim’s PSR-7 Request implementation provides these additional proprietary methods to help you further inspect the HTTP request. Detect XHR requests You can detect XHR requests by checking if the header X-Requested-With is XMLHttpRequest using the Request’s getHeaderLine() method. POST /path HTTP/1.1 Host: example.com Content-type: application/x-www-form-urlencoded Content-length: 7 X-Requested-With: XMLHttpRequest foo=bar Figure 13: Example XHR request. if ($request->getHeaderLine('X-Requested-With') === 'XMLHttpRequest') { // Do something } Content Type You can fetch the HTTP request content type with the Request object’s getHeaderLine() method. $contentType = $request->getHeaderLine('Content-Type'); Content Length You can fetch the HTTP request content length with the Request object’s getHeaderLine() method. $length = $request->getHeaderLine('Content-Length'); Request Parameter To fetch single request parameter value. You will need to use getServerParams() For example, to get a single Server Parameter: $params = $request->getServerParams(); $authorization = isset($params['HTTP_AUTHORIZATION']) ? $params['HTTP_AUTHORIZATION'] : null; "},"4-request/7-route-object.html":{"url":"4-request/7-route-object.html","title":"Route Object","keywords":"","body":"Route Object Sometimes in middleware you require the parameter of your route. In this example we are checking first that the user is logged in and second that the user has permissions to view the particular video they are attempting to view. get('/course/{id}', Video::class.\":watch\")->add(PermissionMiddleware::class); getRoute(); $courseId = $route->getArgument('id'); // ...do permission logic... return $handler->handle($request); } } Obtain Base Path From Within Route To obtain the base path from within a route simply do the following: get('/', function($request, $response) { $routeContext = RouteContext::fromRequest($request); $basePath = $routeContext->getBasePath(); // ... return $response; }); Attributes With PSR-7 it is possible to inject objects/values into the request object for further processing. In your applications middleware often need to pass along information to your route closure and the way to do it is to add it to the request object via an attribute. Example, Setting a value on your request object. $app->add(function ($request, $handler) { // add the session storage to your request as [READ-ONLY] $request = $request->withAttribute('session', $_SESSION); return $handler->handle($request); }); Example, how to retrieve the value. $app->get('/test', function ($request, $response, $args) { $session = $request->getAttribute('session'); // get the session from the request return $response->write('Yay, ' . $session['name']); }); The request object also has bulk functions as well. $request->getAttributes() and $request->withAttributes() 中间件参数传递 采用request->withAttributes(key,value); "},"5-response/1-overview.html":{"url":"5-response/1-overview.html","title":"Overview","keywords":"","body":"Response Your Slim app’s routes and middleware are given a PSR-7 response object that represents the current HTTP response to be returned to the client. The response object implements the PSR-7 ResponseInterface with which you can inspect and manipulate the HTTP response status, headers, and body. How to get the Response object The PSR-7 response object is injected into your Slim application routes as the second argument to the route callback like this: get('/hello', function (ServerRequest $request, Response $response) { $response->getBody()->write('Hello World'); return $response; }); $app->run(); "},"5-response/2-status.html":{"url":"5-response/2-status.html","title":"Status","keywords":"","body":"The Response Status Every HTTP response has a numeric status code. The status code identifies the type of HTTP response to be returned to the client. The PSR-7 Response object’s default status code is 200 (OK). You can get the PSR-7 Response object’s status code with the getStatusCode() method like this. $status = $response->getStatusCode(); You can copy a PSR-7 Response object and assign a new status code like this: $newResponse = $response->withStatus(302); "},"5-response/3-headers.html":{"url":"5-response/3-headers.html","title":"Headers","keywords":"","body":"The Response Headers Every HTTP response has headers. These are metadata that describe the HTTP response but are not visible in the response’s body. The PSR-7 Response object provides several methods to inspect and manipulate its headers. Get All Headers You can fetch all HTTP response headers as an associative array with the PSR-7 Response object’s getHeaders() method. The resultant associative array’s keys are the header names and its values are themselves a numeric array of string values for their respective header name. $headers = $response->getHeaders(); foreach ($headers as $name => $values) { echo $name . \": \" . implode(\", \", $values); } Get One Header You can get a single header’s value(s) with the PSR-7 Response object’s getHeader($name) method. This returns an array of values for the given header name. Remember, a single HTTP header may have more than one value! $headerValueArray = $response->getHeader('Vary'); You may also fetch a comma-separated string with all values for a given header with the PSR-7 Response object’s getHeaderLine($name) method. Unlike the getHeader($name) method, this method returns a comma-separated string. $headerValueString = $response->getHeaderLine('Vary'); Detect Header You can test for the presence of a header with the PSR-7 Response object’s hasHeader($name) method. if ($response->hasHeader('Vary')) { // Do something } Figure 8: Detect presence of a specific HTTP header. Set Header You can set a header value with the PSR-7 Response object’s withHeader($name, $value) method. $newResponse = $oldResponse->withHeader('Content-type', 'application/json'); Reminder The Response object is immutable. This method returns a copy of the Response object that has the new header value. This method is destructive, and it replaces existing header values already associated with the same header name. Append Header You can append a header value with the PSR-7 Response object’s withAddedHeader($name, $value) method. $newResponse = $oldResponse->withAddedHeader('Allow', 'PUT'); Reminder Unlike the withHeader() method, this method appends the new value to the set of values that already exist for the same header name. The Response object is immutable. This method returns a copy of the Response object that has the appended header value. Remove Header You can remove a header with the Response object’s withoutHeader($name) method. $newResponse = $oldResponse->withoutHeader('Allow'); Reminder The Response object is immutable. This method returns a copy of the Response object that has the appended header value. "},"5-response/4-body.html":{"url":"5-response/4-body.html","title":"Body","keywords":"","body":"The Response Body An HTTP response typically has a body. Just like the PSR-7 Request object, the PSR-7 Response object implements the body as an instance of Psr\\Http\\Message\\StreamInterface. You can get the HTTP response body StreamInterface instance with the PSR-7 Response object’s getBody() method. The getBody() method is preferable if the outgoing HTTP response length is unknown or too large for available memory. $body = $response->getBody(); Figure 12: Get HTTP response body The resultant Psr\\Http\\Message\\StreamInterface instance provides the following methods to read from, iterate, and write to its underlying PHP resource. getSize() tell() eof() isSeekable() seek() rewind() isWritable() write($string) isReadable() read($length) getContents() getMetadata($key = null) Most often, you’ll need to write to the PSR-7 Response object. You can write content to the StreamInterface instance with its write() method like this: $body = $response->getBody(); $body->write('Hello'); You can also replace the PSR-7 Response object’s body with an entirely new StreamInterface instance. This is particularly useful when you want to pipe content from a remote destination (e.g. the filesystem or a remote API) into the HTTP response. You can replace the PSR-7 Response object’s body with its withBody(StreamInterface $body) method. Its argument MUST be an instance of Psr\\Http\\Message\\StreamInterface. use GuzzleHttp\\Psr7\\LazyOpenStream; $newStream = new LazyOpenStream('/path/to/file', 'r'); $newResponse = $oldResponse->withBody($newStream); Reminder The Response object is immutable. This method returns a copy of the Response object that contains the new body. "},"5-response/5-json.html":{"url":"5-response/5-json.html","title":"Json","keywords":"","body":"Returning JSON In it’s simplest form, JSON data can be returned with a default 200 HTTP status code. $data = array('name' => 'Bob', 'age' => 40); $payload = json_encode($data); $response->getBody()->write($payload); return $response ->withHeader('Content-Type', 'application/json'); Figure 15: Returning JSON with a 200 HTTP status code. We can also return JSON data with a custom HTTP status code. $data = array('name' => 'Rob', 'age' => 40); $payload = json_encode($data); $response->getBody()->write($payload); return $response ->withHeader('Content-Type', 'application/json') ->withStatus(201); Figure 16: Returning JSON with a 201 HTTP status code. Reminder The Response object is immutable. This method returns a copy of the Response object that has a new Content-Type header. This method is destructive, and it replaces the existing Content-Type header. Returning a Redirect You can redirect the HTTP client by using the Location header. return $response ->withHeader('Location', 'https://www.example.com') ->withStatus(302); "},"6-routing/1-overview.html":{"url":"6-routing/1-overview.html","title":"Overview","keywords":"","body":"Routing The Slim Framework’s router is built on top of the Fast Route component, and it is remarkably fast and stable. While we are using this component to do all our routing, the app’s core has been entirely decoupled from it and interfaces have been put in place to pave the way for using other routing libraries. "},"6-routing/2-create-routes.html":{"url":"6-routing/2-create-routes.html","title":"Create Routes","keywords":"","body":"How to create routes You can define application routes using proxy methods on the Slim\\App instance. The Slim Framework provides methods for the most popular HTTP methods. GET Route You can add a route that handles only GET HTTP requests with the Slim application’s get() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->get('/books/{id}', function ($request, $response, $args) { // Show book identified by $args['id'] }); POST Route You can add a route that handles only POST HTTP requests with the Slim application’s post() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->post('/books', function ($request, $response, $args) { // Create new book }); PUT Route You can add a route that handles only PUT HTTP requests with the Slim application’s put() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->put('/books/{id}', function ($request, $response, $args) { // Update book identified by $args['id'] }); DELETE Route You can add a route that handles only DELETE HTTP requests with the Slim application’s delete() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->delete('/books/{id}', function ($request, $response, $args) { // Delete book identified by $args['id'] }); OPTIONS Route You can add a route that handles only OPTIONS HTTP requests with the Slim application’s options() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->options('/books/{id}', function ($request, $response, $args) { // Return response headers }); PATCH Route You can add a route that handles only PATCH HTTP requests with the Slim application’s patch() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->patch('/books/{id}', function ($request, $response, $args) { // Apply changes to book identified by $args['id'] }); Any Route You can add a route that handles all HTTP request methods with the Slim application’s any() method. It accepts two arguments: The route pattern (with optional named placeholders) The route callback $app->any('/books/[{id}]', function ($request, $response, $args) { // Apply changes to books or book identified by $args['id'] if specified. // To check which method is used: $request->getMethod(); }); Note that the second parameter is a callback. You could specify a Class which implementes the __invoke() method instead of a Closure. You can then do the mapping somewhere else: $app->any('/user', 'MyRestfulController'); Custom Route You can add a route that handles multiple HTTP request methods with the Slim application’s map() method. It accepts three arguments: Array of HTTP methods The route pattern (with optional named placeholders) The route callback $app->map(['GET', 'POST'], '/books', function ($request, $response, $args) { // Create new book or list all books }); "},"6-routing/3-callbacks.html":{"url":"6-routing/3-callbacks.html","title":"Callbacks","keywords":"","body":"Route callbacks Each routing method described above accepts a callback routine as its final argument. This argument can be any PHP callable, and by default it accepts three arguments. Request The first argument is a Psr\\Http\\Message\\ServerRequestInterface object that represents the current HTTP request. Response The second argument is a Psr\\Http\\Message\\ResponseInterface object that represents the current HTTP response. Arguments The third argument is an associative array that contains values for the current route’s named placeholders. Writing content to the response There are two ways you can write content to the HTTP response. First, you can simply echo() content from the route callback. This content will be appended to the current HTTP response object. Second, you can return a Psr\\Http\\Message\\ResponseInterface object. echo 这种方式会被ob_clean() 违背Slim的设计思想 Closure binding If you use a dependency container and a Closure instance as the route callback, the closure’s state is bound to the Container instance. This means you will have access to the DI container instance inside of the Closure via the $this keyword: $app->get('/hello/{name}', function ($request, $response, $args) { // Use app HTTP cookie service $this->get('cookies')->set('name', [ 'value' => $args['name'], 'expires' => '7 days' ]); }); Heads Up! Slim does not support static closures. 闭包绑定在容器上，具名class method来自定义器，在反射的时候根据__construct()的参数动态绑定，所以在应用层的方法中需要使用容器需要构造函数包含Container $container类型的参数 Redirect helper You can add a route that redirects GET HTTP requests to a different URL with the Slim application’s redirect() method. It accepts three arguments: The route pattern (with optional named placeholders) to redirect from The location to redirect to, which may be a string or a Psr\\Http\\Message\\UriInterface The HTTP status code to use (optional; 302 if unset) $app->redirect('/books', '/library', 301); redirect() routes respond with the status code requested and a Location header set to the second argument. "},"6-routing/4-strategies.html":{"url":"6-routing/4-strategies.html","title":"Strategies","keywords":"","body":"Route strategies The route callback signature is determined by a route strategy. By default, Slim expects route callbacks to accept the request, response, and an array of route placeholder arguments. This is called the RequestResponse strategy. However, you can change the expected route callback signature by simply using a different strategy. As an example, Slim provides an alternative strategy called RequestResponseArgs that accepts request and response, plus each route placeholder as a separate argument. Here is an example of using this alternative strategy: getRouteCollector(); $routeCollector->setDefaultInvocationStrategy(new RequestResponseArgs()); $app->get('/hello/{name}', function ($request, $response, $name) { return $response->write($name); }); Alternatively you can set a different invocation strategy on a per route basis: getRouteCollector(); $route = $app->get('/hello/{name}', function ($request, $response, $name) { return $response->write($name); }); $route->setInvocationStrategy(new RequestResponseArgs()); You can provide your own route strategy by implementing the Slim\\Interfaces\\InvocationStrategyInterface. "},"6-routing/5-placeholders.html":{"url":"6-routing/5-placeholders.html","title":"Placeholders","keywords":"","body":"Route placeholders Each routing method described above accepts a URL pattern that is matched against the current HTTP request URI. Route patterns may use named placeholders to dynamically match HTTP request URI segments. Format A route pattern placeholder starts with a {, followed by the placeholder name, ending with a }. This is an example placeholder named name: $app->get('/hello/{name}', function (Request $request, Response $response, $args) { $name = $args['name']; echo \"Hello, $name\"; }); Optional segments To make a section optional, simply wrap in square brackets: $app->get('/users[/{id}]', function ($request, $response, $args) { // responds to both `/users` and `/users/123` // but not to `/users/` }); Multiple optional parameters are supported by nesting: $app->get('/news[/{year}[/{month}]]', function ($request, $response, $args) { // reponds to `/news`, `/news/2016` and `/news/2016/03` }); For “Unlimited” optional parameters, you can do this: $app->get('/news[/{params:.*}]', function ($request, $response, $args) { // $params is an array of all the optional segments $params = explode('/', $args['params']); }); In this example, a URI of /news/2016/03/20 would result in the $params array containing three elements: ['2016', '03', '20']. Regular expression matching By default the placeholders are written inside {} and can accept any values. However, placeholders can also require the HTTP request URI to match a particular regular expression. If the current HTTP request URI does not match a placeholder regular expression, the route is not invoked. This is an example placeholder named id that requires one or more digits. $app->get('/users/{id:[0-9]+}', function ($request, $response, $args) { // Find user identified by $args['id'] }); "},"6-routing/6-names.html":{"url":"6-routing/6-names.html","title":"Names","keywords":"","body":"Route names Application routes can be assigned a name. This is useful if you want to programmatically generate a URL to a specific route with the RouteParser’s urlFor() method. Each routing method described above returns a Slim\\Route object, and this object exposes a setName() method. $app->get('/hello/{name}', function ($request, $response, $args) { echo \"Hello, \" . $args['name']; })->setName('hello'); You can generate a URL for this named route with the application RouteParser’s urlFor() method. $routeParser = $app->getRouteCollector()->getRouteParser(); echo $routeParser->urlFor('hello', ['name' => 'Josh'], ['example' => 'name']); // Outputs \"/hello/Josh?example=name\" The RouteParser’s urlFor() method accepts three arguments: $routeName The route name. A route’s name can be set via $route->setName('name'). Route mapping methods return an instance of Route so you can set the name directly after mapping the route. e.g.: $app->get('/', function () {...})->setName('name') $data Associative array of route pattern placeholders and replacement values. $queryParams Associative array of query parameters to be appended to the generated url. "},"6-routing/7-groups.html":{"url":"6-routing/7-groups.html","title":"Groups","keywords":"","body":"Route groups To help organize routes into logical groups, the Slim\\App also provides a group() method. Each group’s route pattern is prepended to the routes or groups contained within it, and any placeholder arguments in the group pattern are ultimately made available to the nested routes: $app->group('/users/{id:[0-9]+}', function (RouteCollectorProxy $group) { $group->map(['GET', 'DELETE', 'PATCH', 'PUT'], '', function ($request, $response, $args) { // Find, delete, patch or replace user identified by $args['id'] })->setName('user'); $group->get('/reset-password', function ($request, $response, $args) { // Route for /users/{id:[0-9]+}/reset-password // Reset the password for user identified by $args['id'] })->setName('user-password-reset'); }); The group pattern can be empty, enabling the logical grouping of routes that do not share a common pattern. $app->group('', function (RouteCollectorProxy $group) { $group->get('/billing', function ($request, $response, $args) { // Route for /billing }); $group->get('/invoice/{id:[0-9]+}', function ($request, $response, $args) { // Route for /invoice/{id:[0-9]+} }); })->add(new GroupMiddleware()); Note inside the group closure, Slim binds the closure to the container instance. inside route closure, $this is bound to the instance of Psr\\Container\\ContainerInterface "},"6-routing/8-middleware.html":{"url":"6-routing/8-middleware.html","title":"Middleware","keywords":"","body":"Route middleware You can also attach middleware to any route or route group. $app->group('/foo', function (RouteCollectorProxy $group) { $group->get('/bar', function ($request, $response, $args) { })->add(new RouteMiddleware()); })->add(new GroupMiddleware()); "},"6-routing/9-caching.html":{"url":"6-routing/9-caching.html","title":"Caching","keywords":"","body":"Route expressions caching It’s possible to enable router cache via RouteCollector::setCacheFile(). See examples below: getRouteCollector(); $routeCollector->setCacheFile('/path/to/cache.file'); "},"6-routing/10-container-resolution.html":{"url":"6-routing/10-container-resolution.html","title":"Container Resolution","keywords":"","body":"Container Resolution You are not limited to defining a function for your routes. In Slim there are a few different ways to define your route action functions. In addition to a function, you may use: container_key:method Class:method Class implementing __invoke() method container_key This functionality is enabled by Slim’s Callable Resolver Class. It translates a string entry into a function call. Example: $app->get('/', '\\HomeController:home'); Alternatively, you can take advantage of PHP’s ::class operator which works well with IDE lookup systems and produces the same result: $app->get('/', \\HomeController::class . ':home'); In this code above we are defining a / route and telling Slim to execute the home() method on the HomeController class. Slim first looks for an entry of HomeController in the container, if it’s found it will use that instance otherwise it will call it’s constructor with the container as the first argument. Once an instance of the class is created it will then call the specified method using whatever Strategy you have defined. Registering a controller with the container Create a controller with the home action method. The constructor should accept the dependencies that are required. For example: view = $view; } public function home($request, $response, $args) { // your code here // use $this->view to render the HTML return $response; } } Create a factory in the container that instantiates the controller with the dependencies: $container = $app->getContainer(); $container->set('HomeController', function (ContainerInterface $c) { $view = $c->get('view'); // retrieve the 'view' from the container return new HomeController($view); }); This allows you to leverage the container for dependency injection and so you can inject specific dependencies into the controller. Allow Slim to instantiate the controller Alternatively, if the class does not have an entry in the container, then Slim will pass the container’s instance to the constructor. You can construct controllers with many actions instead of an invokable class which only handles one action. container = $container; } public function home($request, $response, $args) { // your code // to access items in the container... $this->container->get(''); return $response; } public function contact($request, $response, $args) { // your code // to access items in the container... $this->container->get(''); return $response; } } You can use your controller methods like so. $app->get('/', \\HomeController::class . ':home'); $app->get('/contact', \\HomeController::class . ':contact'); Using an invokable class You do not have to specify a method in your route callable and can just set it to be an invokable class such as: container = $container; } public function __invoke($request, $response, $args) { // your code // to access items in the container... $this->container->get(''); return $response; } } You can use this class like so. $app->get('/', \\HomeAction::class); Again, as with controllers, if you register the class name with the container, then you can create a factory and inject just the specific dependencies that you require into your action class. 官方建议的controller 使用container的方式 "},"7-packaged-middleware/1-routing.html":{"url":"7-packaged-middleware/1-routing.html","title":"Routing","keywords":"","body":"Routing Middleware The routing has been implemented as middleware. We are still using FastRoute as the default router but it is not tightly coupled to it. If you wanted to implement another routing library you could by creating your own implementations of the routing interfaces. DispatcherInterface, RouteCollectorInterface, RouteParserInterface and RouteResolverInterface which create a bridge between Slim’s components and the routing library. If you were using determineRouteBeforeAppMiddleware, you need to add the Middleware\\RoutingMiddleware middleware to your application just before your call run() to maintain the previous behaviour. Usage addRoutingMiddleware(); // ... $app->run(); "},"7-packaged-middleware/2-error-handling.html":{"url":"7-packaged-middleware/2-error-handling.html","title":"Error Handling","keywords":"","body":"Error Handling Middleware Things go wrong. You can’t predict errors, but you can anticipate them. Each Slim Framework application has an error handler that receives all uncaught PHP exceptions. This error handler also receives the current HTTP request and response objects, too. The error handler must prepare and return an appropriate Response object to be returned to the HTTP client. Usage addRoutingMiddleware(); /** * @param bool $displayErrorDetails -> Should be set to false in production * @param bool $logErrors -> Parameter is passed to the default ErrorHandler * @param bool $logErrorDetails -> Display error details in error log * which can be replaced by a callable of your choice. * @param \\Psr\\Log\\LoggerInterface $logger -> Optional PSR-3 logger to receive errors * * Note: This middleware should be added last. It will not handle any exceptions/errors * for middleware added after it. */ $errorMiddleware = $app->addErrorMiddleware(true, true, true, $logger); // ... $app->run(); Adding Custom Error Handlers You can now map custom handlers for any type of Exception or Throwable. addRoutingMiddleware(); // Define Custom Error Handler $customErrorHandler = function ( ServerRequestInterface $request, Throwable $exception, bool $displayErrorDetails, bool $logErrors, bool $logErrorDetails, ?LoggerInterface $logger = null ) use ($app) { $logger->error($exception->getMessage()); $payload = ['error' => $exception->getMessage()]; $response = $app->getResponseFactory()->createResponse(); $response->getBody()->write( json_encode($payload, JSON_UNESCAPED_UNICODE) ); return $response; }; // Add Error Middleware $errorMiddleware = $app->addErrorMiddleware(true, true, true, $logger); $errorMiddleware->setDefaultErrorHandler($customErrorHandler); // ... $app->run(); Error Logging If you would like to pipe in custom error logging to the default ErrorHandler that ships with Slim, there are two ways to do it. With the first method, you can simply extend ErrorHandler and stub the logError() method. addRoutingMiddleware(); // Instantiate Your Custom Error Handler $myErrorHandler = new MyErrorHandler($app->getCallableResolver(), $app->getResponseFactory()); // Add Error Middleware $errorMiddleware = $app->addErrorMiddleware(true, true, true); $errorMiddleware->setDefaultErrorHandler($myErrorHandler); // ... $app->run(); With the second method, you can supply a logger that conforms to the PSR-3 standard, such as one from the popular Monolog library. addRoutingMiddleware(); // Instantiate Logger // $logger = ... // Add Error Middleware with Logger $errorMiddleware = $app->addErrorMiddleware(true, true, true, $logger); // ... $app->run(); Error Handling/Rendering The rendering is finally decoupled from the handling. It will still detect the content-type and render things appropriately with the help of ErrorRenderers. The core ErrorHandler extends the AbstractErrorHandler class which has been completely refactored. By default it will call the appropriate ErrorRenderer for the supported content types. The core ErrorHandler defines renderers for the following content types: application/json application/xml and text/xml text/html text/plain For any content type you can register your own error renderer. So first define a new error renderer that implements \\Slim\\Interfaces\\ErrorRendererInterface. And then register that error renderer in the core error handler. In the example below we will register the renderer to be used for text/html content types. addRoutingMiddleware(); // Add Error Middleware $errorMiddleware = $app->addErrorMiddleware(true, true, true); // Get the default error handler and register my custom error renderer. $errorHandler = $errorMiddleware->getDefaultErrorHandler(); $errorHandler->registerErrorRenderer('text/html', MyCustomErrorRenderer::class); // ... $app->run(); Force a specific content type for error rendering By default, the error handler tries to detect the error renderer using the Accept header of the request. If you need to force the error handler to use a specific error renderer you can write the following. $errorHandler->forceContentType('application/json'); New HTTP Exceptions We have added named HTTP exceptions within the application. These exceptions work nicely with the native renderers. They can each have a description and title attribute as well to provide a bit more insight when the native HTML renderer is invoked. The base class HttpSpecializedException extends Exception and comes with the following sub classes: HttpBadRequestException HttpForbiddenException HttpInternalServerErrorException HttpNotAllowedException HttpNotFoundException HttpNotImplementedException HttpUnauthorizedException You can extend the HttpSpecializedException class if they need any other response codes that we decide not to provide with the base repository. Example if you wanted a 504 gateway timeout exception that behaves like the native ones you would do the following: class HttpForbiddenException extends HttpException { protected $code = 504; protected $message = 'Gateway Timeout.'; protected $title = '504 Gateway Timeout'; protected $description = 'Timed out before receiving response from the upstream server.'; } "},"7-packaged-middleware/3-method-overriding.html":{"url":"7-packaged-middleware/3-method-overriding.html","title":"Method Overriding","keywords":"","body":"Method Overriding Middleware The Method Overidding Middleware enables you to use the X-Http-Method-Override request header or the request body parameter _METHOD to override an incoming request’s method. The middleware should be placed after the routing middleware has been added. Usage addRoutingMiddleware(); // Add MethodOverride middleware $methodOverrideMiddleware = new MethodOverrideMiddleware(); $app->add($methodOverrideMiddleware); // ... $app->run(); "},"7-packaged-middleware/4-output-buffering.html":{"url":"7-packaged-middleware/4-output-buffering.html","title":"Output Buffering","keywords":"","body":"Output Buffering Middleware The Output Buffering Middleware enables you to switch between two modes of output buffering: APPEND (default) and PREPEND mode. The APPEND mode will use the existing response body to append the contents. The PREPEND mode will create a new response body object and prepend the contents to the output from the existing response body. This middleware should be placed on the center of the middleware stack so it gets executed last. Usage add($outputBufferingMiddleware); // ... $app->run(); "},"7-packaged-middleware/5-body-parsing.html":{"url":"7-packaged-middleware/5-body-parsing.html","title":"Body Parsing","keywords":"","body":"Body Parsing Middleware It’s very common in web APIs to send data in JSON or XML format. Out of the box, PSR-7 implementations do not support these formats, you have to decode the Request object’s getBody() yourself. As this is a common requirement, Slim 4 provides BodyParsingMiddleware to handle this task. Usage It’s recommended to put the body parsing middleware before the call to addErrorMiddlware, so that the stack looks like this: addBodyParsingMiddleware(); $app->addRoutingMiddleware(); $app->addErrorMiddleware(true, true, true); // ... $app->run(); Posted JSON, form or XML data No changes are required to the POST handler because the BodyParsingMiddleware detects that the Content-Type is set to a JSON media type and so places the decoded body into the Request’s parsed body property. For data posted to the website from a browser, you can use the $request’s getParsedBody() method. This will return an array of the posted data. $app->post('/', function (Request $request, Response $response, $args): Response { $data = $request->getParsedBody(); $html = var_export($data, true); $response->getBody()->write($html); return $response; }); Media type detection The middleware reads the Content-Type from the request header to detect the media type. Checks if this specific media type has a parser registered If not, look for a media type with a structured syntax suffix (RFC 6839), e.g. application/* Supported media types application/json application/x-www-form-urlencoded application/xml text/xml "},"7-packaged-middleware/6-content-length.html":{"url":"7-packaged-middleware/6-content-length.html","title":"Content Length","keywords":"","body":"Content Length Middleware The Content Length Middleware will automatically append a Content-Length header to the response. This is to replace the addContentLengthHeader setting that was removed from Slim 3. This middleware should be placed on the center of the middleware stack so it gets executed last. Usage add($contentLengthMiddleware); // ... $app->run(); "},"8-cook-book/1-trailing-in-routes.html":{"url":"8-cook-book/1-trailing-in-routes.html","title":"Trailing In Routes","keywords":"","body":"Trailing / in route patterns Slim treats a URL pattern with a trailing slash as different to one without. That is, /user and /user/ are different and so can have different callbacks attached. For GET requests a permanent redirect is fine, but for other request methods like POST or PUT the browser will send the second request with the GET method. To avoid this you simply need to remove the trailing slash and pass the manipulated url to the next middleware. If you want to redirect/rewrite all URLs that end in a / to the non-trailing / equivalent, then you can add this middleware: add(function (Request $request, RequestHandler $handler) { $uri = $request->getUri(); $path = $uri->getPath(); if ($path != '/' && substr($path, -1) == '/') { // recursively remove slashes when its more than 1 slash $path = rtrim($path, '/'); // permanently redirect paths with a trailing slash // to their non-trailing counterpart $uri = $uri->withPath($path); if ($request->getMethod() == 'GET') { $response = new Response(); return $response ->withHeader('Location', (string) $uri) ->withStatus(301); } else { $request = $request->withUri($uri); } } return $handler->handle($request); }); Alternatively, consider middlewares/trailing-slash middleware which also allows you to force a trailing slash to be appended to all URLs: use Middlewares\\TrailingSlash; $app->add(new TrailingSlash(true)); // true adds the trailing slash (false removes it) "},"8-cook-book/2-retrieving-current-route.html":{"url":"8-cook-book/2-retrieving-current-route.html","title":"Retrieving Current Route","keywords":"","body":"Retrieving Current Route If you ever need to get access to the current route within your application, you will need to instantiate the RouteContext object using the incoming ServerRequestInterface. From there you can get the route via $routeContext->getRoute() and access the route’s name by using getName() or get the methods supported by this route via getMethods(), etc. Note: If you need to access the RouteContext object during the middleware cycle before reaching the route handler you will need to add the RoutingMiddleware as the outermost middleware before the error handling middleware (See example below). Example: add(function (Request $request, RequestHandler $handler) { $routeContext = RouteContext::fromRequest($request); $route = $routeContext->getRoute(); // return NotFound for non existent route if (empty($route)) { throw new NotFoundException($request, $response); } $name = $route->getName(); $groups = $route->getGroups(); $methods = $route->getMethods(); $arguments = $route->getArguments(); // ... do something with the data ... return $handler->handle($request); }); // The RoutingMiddleware should be added after our CORS middleware so routing is performed first $app->addRoutingMiddleware(); // The ErrorMiddleware should always be the outermost middleware $app->addErrorMiddleware(true, true, true); // ... $app->run(); "},"8-cook-book/3-enabling-cors.html":{"url":"8-cook-book/3-enabling-cors.html","title":"Enabling Cors","keywords":"","body":"Setting up CORS CORS - Cross origin resource sharing A good flowchart for implementing CORS support Reference: CORS server flowchart You can test your CORS Support here: http://www.test-cors.org/ You can read the specification here: https://www.w3.org/TR/cors/ The simple solution For simple CORS requests, the server only needs to add the following header to its response: Access-Control-Allow-Origin: , ... The following code should enable lazy CORS. $app->options('/{routes:.+}', function ($request, $response, $args) { return $response; }); $app->add(function ($request, $handler) { $response = $handler->handle($request); return $response ->withHeader('Access-Control-Allow-Origin', 'http://mysite') ->withHeader('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Accept, Origin, Authorization') ->withHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS'); }); Add the following route as the last route: map(['GET', 'POST', 'PUT', 'DELETE', 'PATCH'], '/{routes:.+}', function ($request, $response) { throw new HttpNotFoundException($request); }); Access-Control-Allow-Methods The following middleware can be used to query Slim’s router and get a list of methods a particular pattern implements. Here is a complete example application: addBodyParsingMiddleware(); // This middleware will append the response header Access-Control-Allow-Methods with all allowed methods $app->add(function (Request $request, RequestHandlerInterface $handler): Response { $routeContext = RouteContext::fromRequest($request); $routingResults = $routeContext->getRoutingResults(); $methods = $routingResults->getAllowedMethods(); $requestHeaders = $request->getHeaderLine('Access-Control-Request-Headers'); $response = $handler->handle($request); $response = $response->withHeader('Access-Control-Allow-Origin', '*'); $response = $response->withHeader('Access-Control-Allow-Methods', implode(',', $methods)); $response = $response->withHeader('Access-Control-Allow-Headers', $requestHeaders); // Optional: Allow Ajax CORS requests with Authorization header // $response = $response->withHeader('Access-Control-Allow-Credentials', 'true'); return $response; }); // The RoutingMiddleware should be added after our CORS middleware so routing is performed first $app->addRoutingMiddleware(); // The routes $app->get('/api/v0/users', function (Request $request, Response $response): Response { $response->getBody()->write('List all users'); return $response; }); $app->get('/api/v0/users/{id}', function (Request $request, Response $response, array $arguments): Response { $userId = (int)$arguments['id']; $response->getBody()->write(sprintf('Get user: %s', $userId)); return $response; }); $app->post('/api/v0/users', function (Request $request, Response $response): Response { // Retrieve the JSON data $parameters = (array)$request->getParsedBody(); $response->getBody()->write('Create user'); return $response; }); $app->delete('/api/v0/users/{id}', function (Request $request, Response $response, array $arguments): Response { $userId = (int)$arguments['id']; $response->getBody()->write(sprintf('Delete user: %s', $userId)); return $response; }); // Allow preflight requests // Due to the behaviour of browsers when sending a request, // you must add the OPTIONS method. Read about preflight. $app->options('/api/v0/users', function (Request $request, Response $response): Response { // Do nothing here. Just return the response. return $response; }); // Allow additional preflight requests $app->options('/api/v0/users/{id}', function (Request $request, Response $response): Response { return $response; }); // Using groups $app->group('/api/v0/users/{id:[0-9]+}', function (RouteCollectorProxy $group) { $group->put('', function (Request $request, Response $response, array $arguments): Response { // Your code here... $userId = (int)$arguments['id']; $response->getBody()->write(sprintf('Put user: %s', $userId)); return $response; }); $group->patch('', function (Request $request, Response $response, array $arguments): Response { $userId = (int)$arguments['id']; $response->getBody()->write(sprintf('Patch user: %s', $userId)); return $response; }); // Allow preflight requests $group->options('', function (Request $request, Response $response): Response { return $response; }); }); $app->run(); Access-Control-Allow-Credentials If the request contains credentials (cookies, authorization headers or TLS client certificates), you might need to add an Access-Control-Allow-Credentials header to the response object. $response = $response->withHeader('Access-Control-Allow-Credentials', 'true'); "},"8-cook-book/4-uploading-files-using-post-forms.html":{"url":"8-cook-book/4-uploading-files-using-post-forms.html","title":"Uploading Files Using Post Forms","keywords":"","body":"Uploading files using POST forms Files that are uploaded using forms in POST requests can be retrieved with the Request method getUploadedFiles(). When uploading files using a POST request, make sure your file upload form has the attribute enctype=\"multipart/form-data\" otherwise getUploadedFiles() will return an empty array. If multiple files are uploaded for the same input name, add brackets after the input name in the HTML, otherwise only one uploaded file will be returned for the input name by getUploadedFiles(). Below is an example HTML form that contains both single and multiple file uploads. Add file (single): Add files (up to 2): Add files (multiple): Uploaded files can be moved to a directory using the moveTo method. Below is an example application that handles the uploaded files of the HTML form above. set('upload_directory', __DIR__ . '/uploads'); AppFactory::setContainer($container); $app = AppFactory::create(); $app->post('/', function(Request $request, Response $response) { $directory = $this->get('upload_directory'); $uploadedFiles = $request->getUploadedFiles(); // handle single input with single file upload $uploadedFile = $uploadedFiles['example1']; if ($uploadedFile->getError() === UPLOAD_ERR_OK) { $filename = moveUploadedFile($directory, $uploadedFile); $response->write('uploaded ' . $filename . ''); } // handle multiple inputs with the same key foreach ($uploadedFiles['example2'] as $uploadedFile) { if ($uploadedFile->getError() === UPLOAD_ERR_OK) { $filename = moveUploadedFile($directory, $uploadedFile); $response->write('uploaded ' . $filename . ''); } } // handle single input with multiple file uploads foreach ($uploadedFiles['example3'] as $uploadedFile) { if ($uploadedFile->getError() === UPLOAD_ERR_OK) { $filename = moveUploadedFile($directory, $uploadedFile); $response->write('uploaded ' . $filename . ''); } } return $response; }); /** * Moves the uploaded file to the upload directory and assigns it a unique name * to avoid overwriting an existing uploaded file. * * @param string $directory directory to which the file is moved * @param UploadedFileInterface $uploaded file uploaded file to move * @return string filename of moved file */ function moveUploadedFile($directory, UploadedFileInterface $uploadedFile) { $extension = pathinfo($uploadedFile->getClientFilename(), PATHINFO_EXTENSION); $basename = bin2hex(random_bytes(8)); // see http://php.net/manual/en/function.random-bytes.php $filename = sprintf('%s.%0.8s', $basename, $extension); $uploadedFile->moveTo($directory . DIRECTORY_SEPARATOR . $filename); return $filename; } $app->run(); "},"9-source-code/1-catalogue.html":{"url":"9-source-code/1-catalogue.html","title":"Catalogue","keywords":"","body":"目录结构 ├── CONTRIBUTING.md ├── LICENSE ├── README.md ├── app │ ├── dependencies.php │ ├── middleware.php │ ├── repositories.php │ ├── routes.php │ └── settings.php ├── composer.json ├── composer.lock ├── docker-compose.yml ├── logs │ └── README.md ├── phpstan.neon.dist ├── phpunit.xml ├── public │ ├── index-test.php │ ├── index.php │ └── web ├── runtime │ ├── access.log │ └── error.log ├── src │ ├── Application │ ├── Domain │ └── Infrastructure ├── tests │ ├── Application │ ├── Domain │ ├── Infrastructure │ ├── TestCase.php │ └── bootstrap.php ├── var │ └── cache └── vendor app 配置目录，设置配置，中间件配置，路由配置，依赖配置 public 公共入口 index.php 和 前端文件，部署分离可单独拆分 src 后端代码 ├── Application │ ├── Actions │ ├── Controller │ ├── Handlers │ ├── Middleware │ └── ResponseEmitter ├── Domain │ ├── DomainException │ └── User └── Infrastructure └── Persistence Application 应用控制层，中间件层，Handlers 层 Domain 领域模型层 Infrastructure 基础设施 持久化层，邮件发送，消息通知 Service 服务层 "},"9-source-code/2-autoload.html":{"url":"9-source-code/2-autoload.html","title":"Autoload","keywords":"","body":"自动加载 composer 配置加载 \"autoload\": { \"psr-4\": { \"App\\\\\": \"src/\" //配置目录映射 } }, \"autoload-dev\": { \"psr-4\": { \"Tests\\\\\": \"tests/\" } }, \"scripts\": { \"start\": \"php -S localhost:8080 -t public\", \"test\": \"phpunit\" } Composer\\Autoload\\ClassLoader Object ( [prefixLengthsPsr4:Composer\\Autoload\\ClassLoader:private] => Array ( [p] => Array ( [phpDocumentor\\Reflection\\] => 25 ) [Z] => Array ( [Zend\\Diactoros\\] => 15 ) . . . [C] => Array ( [Chadicus\\Slim\\OAuth2\\Middleware\\] => 32 [Chadicus\\Slim\\OAuth2\\Http\\] => 26 [Chadicus\\Psr\\Middleware\\] => 24 ) [A] => Array ( [App\\] => 4 ) ) [prefixDirsPsr4:Composer\\Autoload\\ClassLoader:private] => Array ( [phpDocumentor\\Reflection\\] => Array ( [0] => /Users/nuxse/tms/vendor/composer/../phpdocumentor/reflection-common/src [1] => /Users/nuxse/tms/vendor/composer/../phpdocumentor/reflection-docblock/src [2] => /Users/nuxse/tms/vendor/composer/../phpdocumentor/type-resolver/src ) . . . [App\\] => Array ( [0] => /Users/nuxse/tms/vendor/composer/../../src ) ) 1 配置composer 2 composer install 3 入口文件引用vender 下的composer Autoload 文件 php 可以配置多个autoload 注册函数，按注册的顺序查找 类的查找逻辑就是已知class name 和 namespace ,通过建立的映射逻辑找到文件并包含进来 范例如下: spl_autoload_register( function (string $class) { static $classes = null; if ($classes === null) { $classes = [ ]; } $map_class = $class; if (isset($classes[$map_class])) { $file = __DIR__ .DIRECTORY_SEPARATOR. $classes[$map_class].'.php'; }else{ //处理命名空间的映射关系 $namespace_class = str_replace('\\\\',DIRECTORY_SEPARATOR,$class); $file = ROOT.DIRECTORY_SEPARATOR.$namespace_class.'.php'; } if(file_exists($file)) { require $file; } } ); 如果class name 和 namespce 跟vendor里面冲突可能会导致加载到错误的文件 "},"9-source-code/3-index.html":{"url":"9-source-code/3-index.html","title":"Index","keywords":"","body":"Index.php 入口文件解析 enableCompilation(__DIR__ . '/../var/cache'); } //按需引入配置文件 // Set up settings $settings = require __DIR__ . '/../app/settings.php'; $settings($containerBuilder); // Set up dependencies $dependencies = require __DIR__ . '/../app/dependencies.php'; $dependencies($containerBuilder); // Set up repositories $repositories = require __DIR__ . '/../app/repositories.php'; $repositories($containerBuilder); // Build PHP-DI Container instance $container = $containerBuilder->build(); // Instantiate the app AppFactory::setContainer($container); //container创建在app之前 $app = AppFactory::create(); $callableResolver = $app->getCallableResolver(); // Register middleware $middleware = require __DIR__ . '/../app/middleware.php'; $middleware($app); // Register routes $routes = require __DIR__ . '/../app/routes.php'; $routes($app); /** @var bool $displayErrorDetails */ $displayErrorDetails = $container->get('settings')['displayErrorDetails']; // Create Request object from globals $serverRequestCreator = ServerRequestCreatorFactory::create(); $request = $serverRequestCreator->createServerRequestFromGlobals(); // Create Error Handler $responseFactory = $app->getResponseFactory(); $errorHandler = new HttpErrorHandler($callableResolver, $responseFactory); //非exception的异常捕获 // Create Shutdown Handler $shutdownHandler = new ShutdownHandler($request, $errorHandler, $displayErrorDetails); register_shutdown_function($shutdownHandler); // Add Routing Middleware $app->addRoutingMiddleware(); // Add Error Middleware $errorMiddleware = $app->addErrorMiddleware($displayErrorDetails, false, false); $errorMiddleware->setDefaultErrorHandler($errorHandler); //上面依赖了request 和 response 如果没有依赖可以直接app->run // Run App & Emit Response $response = $app->handle($request); $responseEmitter = new ResponseEmitter(); $responseEmitter->emit($response); 可以分别写不同的index-type.php的入口文件对应不同的环境，如果测试，开发，灰度，生产环境 不同的环境 nginx配置文件指向的入口文件不同即可，其他web server同理 "},"9-source-code/4-repository.html":{"url":"9-source-code/4-repository.html","title":"Repository","keywords":"","body":"Repository addDefinitions([ UserRepository::class => \\DI\\autowire(InMemoryUserRepository::class), ]); }; 这是Slim create project给的引用模型仓库的示例 对于匿名函数，传入container实例，并将模型对应仓库类绑定到容器上 在应用层的构造函数传入，仓库依赖就可以在应用层使用 abstract class UserAction extends Action { /** * @var UserRepository */ protected $userRepository; /** * @param LoggerInterface $logger * @param UserRepository $userRepository */ public function __construct(LoggerInterface $logger, UserRepository $userRepository) { parent::__construct($logger); $this->userRepository = $userRepository; } } 仓库依赖写入了配置文件，由反射自动解析并加载 如果模型过多，仓库配置文件会很臃肿 "},"9-source-code/5-logger.html":{"url":"9-source-code/5-logger.html","title":"Logger","keywords":"","body":"Logger addDefinitions([ LoggerInterface::class => function (ContainerInterface $c) { $settings = $c->get('settings'); $loggerSettings = $settings['logger']; $logger = new Logger($loggerSettings['name']); $processor = new UidProcessor(); $logger->pushProcessor($processor); $handler = new StreamHandler($loggerSettings['path'], $loggerSettings['level']); $logger->pushHandler($handler); return $logger; }, ]); }; logger的使用跟仓库的类似，需要在抽象的action 或者 controller构造函数中配置依赖 不太建议这种使用方式 1 针对不同类型的日志，可能需要的格式化方式，存储，处理过程不一样 2 日志跟业务层不能太耦合，应该是可被替换的 3 可以建立不同类型的日志处理器 "},"9-source-code/6-route.html":{"url":"9-source-code/6-route.html","title":"Route","keywords":"","body":"Route 路由的解析到实例化对应的应用层回调流程 大致流程 应用入口 App->handle() 中间件调度器 MiddlewareDispatcher->handle() 最靠近核心的路由中间件 路由解决方案 App 构造函数 $this->routeResolver = $routeResolver ?? new RouteResolver($this->routeCollector); $routeRunner = new RouteRunner($this->routeResolver, $this->routeCollector->getRouteParser(), $this); if (!$middlewareDispatcher) { $middlewareDispatcher = new MiddlewareDispatcher($routeRunner, $this->callableResolver, $container); } else { $middlewareDispatcher->seedMiddlewareStack($routeRunner); } $this->middlewareDispatcher = $middlewareDispatcher; RouteRunner handle public function handle(ServerRequestInterface $request): ResponseInterface { // If routing hasn't been done, then do it now so we can dispatch if ($request->getAttribute(RouteContext::ROUTING_RESULTS) === null) { $routingMiddleware = new RoutingMiddleware($this->routeResolver, $this->routeParser); $request = $routingMiddleware->performRouting($request); } if ($this->routeCollectorProxy !== null) { $request = $request->withAttribute( RouteContext::BASE_PATH, $this->routeCollectorProxy->getBasePath() ); } /** @var Route $route */ $route = $request->getAttribute(RouteContext::ROUTE); return $route->run($request); } Route run() /** * {@inheritdoc} */ public function run(ServerRequestInterface $request): ResponseInterface { if (!$this->groupMiddlewareAppended) { $this->appendGroupMiddlewareToRoute(); } return $this->middlewareDispatcher->handle($request); } Route 也具备中间件概念，最靠近路由器的中间件路由解决中间件 public function __construct( array $methods, string $pattern, $callable, ResponseFactoryInterface $responseFactory, CallableResolverInterface $callableResolver, ?ContainerInterface $container = null, ?InvocationStrategyInterface $invocationStrategy = null, array $groups = [], int $identifier = 0 ) { $this->methods = $methods; $this->pattern = $pattern; $this->callable = $callable; $this->responseFactory = $responseFactory; $this->callableResolver = $callableResolver; $this->container = $container; $this->invocationStrategy = $invocationStrategy ?? new RequestResponse(); $this->groups = $groups; $this->identifier = 'route' . $identifier; $this->middlewareDispatcher = new MiddlewareDispatcher($this, $callableResolver, $container); } Route 的handle if ($this->callableResolver instanceof AdvancedCallableResolverInterface) { $callable = $this->callableResolver->resolveRoute($this->callable); } else { $callable = $this->callableResolver->resolve($this->callable); } $strategy = $this->invocationStrategy; 返回路由器匹配的回调 CallableResolver private function resolveByPredicate($toResolve, callable $predicate, string $defaultMethod): callable { //匿名函数绑定到容器上 if (is_callable($toResolve)) { return $this->bindToContainer($toResolve); } $resolved = $toResolve; if ($predicate($toResolve)) { $resolved = [$toResolve, $defaultMethod]; } if (is_string($toResolve)) { [$instance, $method] = $this->resolveSlimNotation($toResolve); if ($predicate($instance) && $method === null) { $method = $defaultMethod; } $resolved = [$instance, $method ?? '__invoke']; } $callable = $this->assertCallable($resolved, $toResolve); return $this->bindToContainer($callable); } //匿名函数挂载到容器上 内部的this指向容器 private function bindToContainer(callable $callable): callable { if (is_array($callable) && $callable[0] instanceof Closure) { $callable = $callable[0]; } if ($this->container && $callable instanceof Closure) { $callable = $callable->bindTo($this->container); } return $callable; } //非匿名函数 private function resolveSlimNotation(string $toResolve): array { preg_match(CallableResolver::$callablePattern, $toResolve, $matches); [$class, $method] = $matches ? [$matches[1], $matches[2]] : [$toResolve, null]; //非匿名函数实例由容器获取 if ($this->container && $this->container->has($class)) { $instance = $this->container->get($class); } else { if (!class_exists($class)) { throw new RuntimeException(sprintf('Callable %s does not exist', $class)); } $instance = new $class($this->container); } return [$instance, $method]; } public function has($name) { if (! is_string($name)) { throw new InvalidArgumentException(sprintf( 'The name parameter must be of type string, %s given', is_object($name) ? get_class($name) : gettype($name) )); } if (array_key_exists($name, $this->resolvedEntries)) { return true; } $definition = $this->getDefinition($name); if ($definition === null) { return false; } return $this->definitionResolver->isResolvable($definition); } private function getDefinition($name) { // Local cache that avoids fetching the same definition twice if (!array_key_exists($name, $this->fetchedDefinitions)) { $this->fetchedDefinitions[$name] = $this->definitionSource->getDefinition($name); } return $this->fetchedDefinitions[$name]; } SourceChain public function getDefinition(string $name, int $startIndex = 0) { $count = count($this->sources); for ($i = $startIndex; $i sources[$i]; $definition = $source->getDefinition($name); if ($definition) { if ($definition instanceof ExtendsPreviousDefinition) { $this->resolveExtendedDefinition($definition, $i); } return $definition; } } return null; } ReflectionBasedAutowiring public function autowire(string $name, ObjectDefinition $definition = null) { $className = $definition ? $definition->getClassName() : $name; if (!class_exists($className) && !interface_exists($className)) { return $definition; } $definition = $definition ?: new ObjectDefinition($name); // Constructor $class = new \\ReflectionClass($className); $constructor = $class->getConstructor(); if ($constructor && $constructor->isPublic()) { $constructorInjection = MethodInjection::constructor($this->getParametersDefinition($constructor)); $definition->completeConstructorInjection($constructorInjection); } return $definition; } ObjectCreator 此处解析配置文件对应的应用层的回调函数，根据类的构造函数参数依赖实例化类 private function createInstance(ObjectDefinition $definition, array $parameters) { // Check that the class is instantiable if (! $definition->isInstantiable()) { // Check that the class exists if (! $definition->classExists()) { throw InvalidDefinition::create($definition, sprintf( 'Entry \"%s\" cannot be resolved: the class doesn\\'t exist', $definition->getName() )); } throw InvalidDefinition::create($definition, sprintf( 'Entry \"%s\" cannot be resolved: the class is not instantiable', $definition->getName() )); } $classname = $definition->getClassName(); $classReflection = new ReflectionClass($classname); $constructorInjection = $definition->getConstructorInjection(); try { $args = $this->parameterResolver->resolveParameters( $constructorInjection, $classReflection->getConstructor(), $parameters ); $object = new $classname(...$args); $this->injectMethodsAndProperties($object, $definition); } catch (NotFoundExceptionInterface $e) { throw new DependencyException(sprintf( 'Error while injecting dependencies into %s: %s', $classReflection->getName(), $e->getMessage() ), 0, $e); } catch (InvalidDefinition $e) { throw InvalidDefinition::create($definition, sprintf( 'Entry \"%s\" cannot be resolved: %s', $definition->getName(), $e->getMessage() )); } return $object; } options('/{routes:.*}', function (Request $request, Response $response) { // CORS Pre-Flight OPTIONS Request Handler return $response; }); $app->get('/', function (Request $request, Response $response) { $response->getBody()->write('Hello world!'); return $response; }); $app->group('/users', function (Group $group) { $group->get('', ListUsersAction::class); $group->get('/{id}', ViewUserAction::class); }); $app->group('/user',function(\\Slim\\Interfaces\\RouteCollectorProxyInterface $group){ $group->post('/login', \\App\\Application\\Controller\\UserController::class.':login'); $group->get('/logout', \\App\\Application\\Controller\\UserController::class.':logout'); }); $app->group('/ship',function(\\Slim\\Interfaces\\RouteCollectorProxyInterface $group){ $group->get('/list', \\App\\Application\\Controller\\ShipController::class.':list'); $group->post('/createTable', \\App\\Application\\Controller\\ShipController::class.':createTable'); }); $app->get('/user/info[/{id}]', \\App\\Application\\Controller\\UserController::class.':info'); $app->get('/menu', \\App\\Application\\Controller\\MenuController::class.':list'); $app->get('/clear', \\App\\Application\\Controller\\ClearController::class.':handle'); $app->post('/rating/handle', \\App\\Application\\Controller\\RatingController::class.':handle'); $app->get('/pdf/download', \\App\\Application\\Controller\\PdfController::class.':download'); $app->get('/pdf/preview', \\App\\Application\\Controller\\PdfController::class.':preview'); $app->get('/log/info', \\App\\Application\\Controller\\LogController::class.':info'); }; 路由分组 $app->group('/users', function (Group $group) { $group->get('', ListUsersAction::class); $group->get('/{id}', ViewUserAction::class); }); 路由参数 $app->get('/user/info[/{id}]', \\App\\Application\\Controller\\UserController::class.':info'); 针对单个或者分组都可以挂载中间件 对于中间件 除了某个路由之外的绑定 检测uri $sessionId = $request->getCookieParams()['PHPSESSID'] ?: null; $session = $_SESSION[$sessionId] ?? null; if($request->getUri()->getPath() == '/user/login') { return $handler->handle($request); } //比如对于不是登陆接口的请求都需要登录态检测，可以在中间件获取当前的path if (empty($session)) { return $this->unAuthorization(); 可以配置一个ignore url Access+IgnoreAcess $app->group('',function(Group $group){ $group->get('/log/info', \\App\\Application\\Controller\\LogController::class.':info')->setName('this is set name'); })->addMiddleware(new \\App\\Application\\Middleware\\AccessMiddleware()); $app->group('',function(Group $group){ $group->get('/log/info', \\App\\Application\\Controller\\LogController::class.':info')->setName('this is set name'); })->addMiddleware(new \\App\\Application\\Middleware\\IgnoreAccessMiddleware()); 可以在Access外层配置一个IgnoreAccess中间件，分组的时候可以对于不需要access的分组到一组并加载IgnoreAccessMiddleware class IgnoreAccessMiddleware implements Middleware { /** * {@inheritdoc} */ public function process(Request $request, RequestHandler $handler): Response { echo __CLASS__,__METHOD__; $request->withAttribute('ignore_access',true); //设置属性 在Access阶段检测 return $handler->handle($request); } } 2中方案都可以，暂时没找到其他优雅的方案 "},"9-source-code/7-middleware.html":{"url":"9-source-code/7-middleware.html","title":"Middleware","keywords":"","body":"Middleware 浅见: 代码执行过程，请求的生命周期都可以看成是一条生产线，原材料是输入，成品是输出，中间的各种操作处理就类比代码的执行逻辑。中间件就类似流水线上的每一道工序，接收上一道工序的成品，在此基础上加工自己的处理逻辑扔给下一道工序处理。 工序有先后，中间件也有先后，有些工序先后不用那么强制，中间件也一样。但是某些工序的顺序需要精心设计，比如包装这道工序肯定不能放在流水线中间。 App的入口调度就是对中间件调度器的调用 public function handle(ServerRequestInterface $request): ResponseInterface { $response = $this->middlewareDispatcher->handle($request); /** * This is to be in compliance with RFC 2616, Section 9. * If the incoming request method is HEAD, we need to ensure that the response body * is empty as the request may fall back on a GET route handler due to FastRoute's * routing logic which could potentially append content to the response body * https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4 */ $method = strtoupper($request->getMethod()); if ($method === 'HEAD') { $emptyBody = $this->responseFactory->createResponse()->getBody(); return $response->withBody($emptyBody); } return $response; } seedMiddlewareStack($kernel); $this->callableResolver = $callableResolver; $this->container = $container; } /** * {@inheritdoc} */ public function seedMiddlewareStack(RequestHandlerInterface $kernel): void { $this->tip = $kernel; } /** * Invoke the middleware stack * * @param ServerRequestInterface $request * @return ResponseInterface */ public function handle(ServerRequestInterface $request): ResponseInterface { return $this->tip->handle($request); } /** * Add a new middleware to the stack * * Middleware are organized as a stack. That means middleware * that have been added before will be executed after the newly * added one (last in, first out). * * @param MiddlewareInterface|string|callable $middleware * @return MiddlewareDispatcherInterface */ public function add($middleware): MiddlewareDispatcherInterface { if ($middleware instanceof MiddlewareInterface) { return $this->addMiddleware($middleware); } if (is_string($middleware)) { return $this->addDeferred($middleware); } if (is_callable($middleware)) { return $this->addCallable($middleware); } throw new RuntimeException( 'A middleware must be an object/class name referencing an implementation of ' . 'MiddlewareInterface or a callable with a matching signature.' ); } /** * Add a new middleware to the stack * * Middleware are organized as a stack. That means middleware * that have been added before will be executed after the newly * added one (last in, first out). * * @param MiddlewareInterface $middleware * @return MiddlewareDispatcherInterface */ public function addMiddleware(MiddlewareInterface $middleware): MiddlewareDispatcherInterface { /** * 这里是关键点 比较有意思 * 初始节点是app实例化的路由器 * 每次新增中间件都类似在链表头部插入数据 * * 将当前的节点预存 * 新增的节点为当前节点，当前节点的下一个节点指向旧的节点 * 类似逆序构建链表 */ $next = $this->tip; $this->tip = new class ($middleware, $next) implements RequestHandlerInterface { private $middleware; private $next; public function __construct(MiddlewareInterface $middleware, RequestHandlerInterface $next) { $this->middleware = $middleware; $this->next = $next; } public function handle(ServerRequestInterface $request): ResponseInterface { return $this->middleware->process($request, $this->next); } }; return $this; } . . } "},"9-source-code/8-container.html":{"url":"9-source-code/8-container.html","title":"Container","keywords":"","body":"Container build(); * * @api * * @since 3.2 * @author Matthieu Napoli */ class ContainerBuilder { /** * Name of the container class, used to create the container. * @var string */ private $containerClass; /** * Name of the container parent class, used on compiled container. * @var string */ private $containerParentClass; /** * @var bool */ private $useAutowiring = true; //默认采用反射自动装配器 /** * @var bool */ private $useAnnotations = false; /** * @var bool */ private $ignorePhpDocErrors = false; /** * If true, write the proxies to disk to improve performances. * @var bool */ private $writeProxiesToFile = false; /** * Directory where to write the proxies (if $writeProxiesToFile is enabled). * @var string|null */ private $proxyDirectory; /** * If PHP-DI is wrapped in another container, this references the wrapper. * @var ContainerInterface */ private $wrapperContainer; /** * @var DefinitionSource[]|string[]|array[] */ private $definitionSources = []; /** * Whether the container has already been built. * @var bool */ private $locked = false; /** * @var string|null */ private $compileToDirectory; /** * @var bool */ private $sourceCache = false; /** * @var string */ protected $sourceCacheNamespace; /** * Build a container configured for the dev environment. */ public static function buildDevContainer() : Container { return new Container; } /** * @param string $containerClass Name of the container class, used to create the container. */ public function __construct(string $containerClass = Container::class) { $this->containerClass = $containerClass; } /** * Build and return a container. * * @return Container */ public function build() { $sources = array_reverse($this->definitionSources); if ($this->useAnnotations) { $autowiring = new AnnotationBasedAutowiring($this->ignorePhpDocErrors); $sources[] = $autowiring; } elseif ($this->useAutowiring) { //这里解析链 默认采用反射 $autowiring = new ReflectionBasedAutowiring; $sources[] = $autowiring; } else { $autowiring = new NoAutowiring; } $sources = array_map(function ($definitions) use ($autowiring) { if (is_string($definitions)) { // File return new DefinitionFile($definitions, $autowiring); } elseif (is_array($definitions)) { return new DefinitionArray($definitions, $autowiring); } return $definitions; }, $sources); $source = new SourceChain($sources); // Mutable definition source $source->setMutableDefinitionSource(new DefinitionArray([], $autowiring)); if ($this->sourceCache) { if (!SourceCache::isSupported()) { throw new \\Exception('APCu is not enabled, PHP-DI cannot use it as a cache'); } // Wrap the source with the cache decorator $source = new SourceCache($source, $this->sourceCacheNamespace); } $proxyFactory = new ProxyFactory( $this->writeProxiesToFile, $this->proxyDirectory ); $this->locked = true; $containerClass = $this->containerClass; if ($this->compileToDirectory) { $compiler = new Compiler($proxyFactory); $compiledContainerFile = $compiler->compile( $source, $this->compileToDirectory, $containerClass, $this->containerParentClass, $this->useAutowiring || $this->useAnnotations ); // Only load the file if it hasn't been already loaded // (the container can be created multiple times in the same process) if (!class_exists($containerClass, false)) { require $compiledContainerFile; } } return new $containerClass($source, $proxyFactory, $this->wrapperContainer); } . . } 挂在到App上 AppFactory::setContainer($container); $app = AppFactory::create(); */ class Container implements ContainerInterface, FactoryInterface, InvokerInterface { /** * Map of entries that are already resolved. * @var array */ protected $resolvedEntries = []; /** * @var MutableDefinitionSource */ private $definitionSource; /** * @var DefinitionResolver */ private $definitionResolver; /** * Map of definitions that are already fetched (local cache). * * @var (Definition|null)[] */ private $fetchedDefinitions = []; /** * Array of entries being resolved. Used to avoid circular dependencies and infinite loops. * @var array */ protected $entriesBeingResolved = []; /** * @var InvokerInterface|null */ private $invoker; /** * Container that wraps this container. If none, points to $this. * * @var ContainerInterface */ protected $delegateContainer; /** * @var ProxyFactory */ protected $proxyFactory; /** * Use `$container = new Container()` if you want a container with the default configuration. * * If you want to customize the container's behavior, you are discouraged to create and pass the * dependencies yourself, the ContainerBuilder class is here to help you instead. * * @see ContainerBuilder * * @param ContainerInterface $wrapperContainer If the container is wrapped by another container. */ public function __construct( MutableDefinitionSource $definitionSource = null, ProxyFactory $proxyFactory = null, ContainerInterface $wrapperContainer = null ) { $this->delegateContainer = $wrapperContainer ?: $this; $this->definitionSource = $definitionSource ?: $this->createDefaultDefinitionSource(); $this->proxyFactory = $proxyFactory ?: new ProxyFactory(false); $this->definitionResolver = new ResolverDispatcher($this->delegateContainer, $this->proxyFactory); // Auto-register the container $this->resolvedEntries = [ self::class => $this, ContainerInterface::class => $this->delegateContainer, FactoryInterface::class => $this, InvokerInterface::class => $this, ]; } /** * Returns an entry of the container by its name. * * @param string $name Entry name or a class name. * * @throws DependencyException Error while resolving the entry. * @throws NotFoundException No entry found for the given name. * @return mixed */ public function get($name) { //根据类名获取实例 // If the entry is already resolved we return it if (isset($this->resolvedEntries[$name]) || array_key_exists($name, $this->resolvedEntries)) { return $this->resolvedEntries[$name]; } $definition = $this->getDefinition($name); if (! $definition) { throw new NotFoundException(\"No entry or class found for '$name'\"); } $value = $this->resolveDefinition($definition); $this->resolvedEntries[$name] = $value; return $value; } /** * @param string $name * * @return Definition|null */ private function getDefinition($name) { //定义的解析链解析 // Local cache that avoids fetching the same definition twice if (!array_key_exists($name, $this->fetchedDefinitions)) { $this->fetchedDefinitions[$name] = $this->definitionSource->getDefinition($name); } return $this->fetchedDefinitions[$name]; } /** * Test if the container can provide something for the given name. * * @param string $name Entry name or a class name. * * @throws InvalidArgumentException The name parameter must be of type string. * @return bool */ public function has($name) { if (! is_string($name)) { throw new InvalidArgumentException(sprintf( 'The name parameter must be of type string, %s given', is_object($name) ? get_class($name) : gettype($name) )); } if (array_key_exists($name, $this->resolvedEntries)) { return true; } $definition = $this->getDefinition($name); if ($definition === null) { return false; } return $this->definitionResolver->isResolvable($definition); } . . . private function createDefaultDefinitionSource() : SourceChain { $source = new SourceChain([new ReflectionBasedAutowiring]); $source->setMutableDefinitionSource(new DefinitionArray([], new ReflectionBasedAutowiring)); return $source; } } 容器与对象缓存器 容器用来解决实例化加载的问题，是一个全局的对象树 可以预先将对象实例化之后，句柄挂载到容器上，在应用层就可以直接使用 容器是一个对象的挂载树，所以在对象实例查找，获取，设置的过程需要判断当前对象是否已经存在，避免多次实例化 容器自身也是一个对象，存储于内存中，所以在使用过程中避免了对象的多次实例化销毁的逻辑 容器加载如果是常驻内存的模型，需要防止对象的加载过多导致内存不断持续升高 容器挂载对象，不能代替缓存，比如可以把Logger 挂载到容器，但是不能将UserId = 100的User这个模型挂载到容器。容器跟对象存储器有很大区别 容器挂载的通常是框架，服务，基础设施等相关的实例化的对象，常常在初始请求的阶段或者预热阶段就实例化了 对象存储器主要是在整个项目的生命周期用于缓存对象，非常驻模式，常常挂载到静态变量即可，或者挂载到外部比如APCU,进程间共享。确保读取写入原子？ 常驻模式下，需要挂载到外部，防止不断增长导致内存溢出 由非常驻进程模型转向常驻进程模型主要的难点在于项目文件的修改，比如php通常使用类的静态变量作为对象的缓存，转向swoole常驻进程模型就需要修改所有涉及到statis 变量的声明和使用。暂时没找到优雅的解决方案，比如php定义扩展代替static语法，在底层解析处理，或者写入特性直接引入就可以修改static的逻辑 "},"9-source-code/9-example.html":{"url":"9-source-code/9-example.html","title":"Example","keywords":"","body":"Example 环境配置 1 php > 7 2 nginx 3 composer 4 phpunit 初始化项目 composer create-project slim/slim-skeleton:dev-master [my-app-name] Web Server log_format access_log_format '|$remote_addr|$remote_user|$time_local|$http_host|$request|$status|$body_bytes_sent|$http_referer|$http_user_agent|$request_time|$proxy_add_x_forwarded_for|$upstream_addr|$cookie_clientId|$cookie_userId|$cookie_pskey|$cookie_fingerprint|$http_x_forwarded_for|'; server { charset utf-8; client_max_body_size 128M; listen 80; server_name 127.0.0.1; root path; # index /web/index.html; #log_format test_k_access_log_443 '|$remote_addr|$remote_user|$time_local|$http_host|$request|$status|$body_bytes_sent|$http_referer|$http_user_agent|$request_time|$proxy_add_x_forwarded_for|$upstream_addr|$cookie_clientId|$cookie_userId|$cookie_pskey|$cookie_fingerprint|$http_x_forwarded_for|'; access_log path/runtime/access.log access_log_format; error_log path/runtime/error.log; location / { try_files /web/$uri /web/index.html 404; } location ~ \\.(jpg|jpeg|gif|png|ico)$ { try_files /web/$uri 404; expires 30m; } location ~ \\.(txt|xml|js|vue|css|ttf|json)$ { try_files /web/$uri 404; expires 7d; } location /protected { deny all; } location ~ \\.php$ { add_header 'Access-Control-Allow-Headers' 'DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type' always; add_header 'Access-Control-Allow-Origin' \"$http_origin\" always; add_header 'Access-Control-Allow-Credentials' \"true\" always; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS' always; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; fastcgi_param REQUEST_URI $php_url?$args; fastcgi_param REAL_REQUEST_URI $request_uri; fastcgi_pass 127.0.0.1:9000; try_files $uri =404; } location ~ /\\.(ht|svn|git) { deny all; } location ~* ^/api(/.*)$ { set $php_url $1; try_files $uri $uri/ /index-test.php?$args; } } 构建项目 ├── CONTRIBUTING.md ├── LICENSE ├── README.md ├── app //默认配置目录 │ ├── dependencies.php //设置依赖 比如日志 邮件 短信 │ ├── middleware.php //中间件配置 │ ├── repositories.php //仓库依赖 │ ├── routes.php //路由设置 │ └── settings.php //设置项 ├── composer.json ├── composer.lock ├── docker-compose.yml ├── logs │ └── README.md ├── phpstan.neon.dist ├── phpunit.xml ├── public //入口文件 │ ├── index-test.php //测试环境配置 │ ├── index.php │ └── web ├── runtime │ ├── access.log │ └── error.log ├── src │ ├── Application //应用层 │ ├── Domain //领域层 │ └── Infrastructure //基础设施层 ├── test.php ├── tests //单元测试 │ ├── Application │ ├── Domain │ ├── Infrastructure │ ├── TestCase.php │ └── bootstrap.php ├── var │ └── cache └── vendor //第三方库 Application的写法可以自己定义，Slim官方的例子是采用Action这种粒度的接口，个人还是喜欢Controller这种聚合粒度 Slim官方采用的DDD架构目录模式也可以变化下 Domain 存储模型和依赖的仓库接口 Application 放置Controller Action,Handler,Middleware ... Infrastructure 放置持久化设施，邮件服务，pdf生成器 "},"9-source-code/10-summary.html":{"url":"9-source-code/10-summary.html","title":"Summary","keywords":"","body":"Summary 面向接口编程 面向抽象而不是具体，可被替换，组件化 约束，约束的本质作用也是用来约束实现类的必须实现的逻辑以至于可以被依赖倒置之后的调用者使用 抽象必然带来理解成本，1+2...+99 很容易知道是在计算1到99的和，（1+99）* 99/2就是抽象 Slim的优缺点 简约，框架实现了处理请求的主要逻辑，恰到好处，不至于太多相比 Symfony or Laravel ，不至于太简陋相比Toro 学习框架的思想，框架基本采用了行业的最新的设计思想和实现标准 适用于小型项目 和 RESTful类型的APIs接口项目，因为大型项目依赖的东西很多，Slim需要不断的composer install第三方库来满足需求，就会导致第三方库的维护问题，说到底还是框架的生态问题。比如Slim应用层的参数校验要么自己实现要么采用第三方库，比如要实现大型框架的过滤器这些对于轮子的依赖 框架都是合适的，如果不合适肯定是项目发展超过了框架的能力，这个时候就需要重新选型。一开始就不合适就选择的问题。 组件化思想 composer 这种引入加载的思想也可以借鉴到项目更细的程度 ​ 权限校验 ​ session控制 ​ 登陆注册 这些通用的逻辑可以组件化 "}}